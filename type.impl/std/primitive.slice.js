(function() {
    var type_impls = Object.fromEntries([["retina_datatypes",[["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-%5BT%5D\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/slice.rs.html#175\">Source</a><a href=\"#impl-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.sort\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/slice.rs.html#237-239\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.sort\" class=\"fn\">sort</a>(&amp;mut self)<div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\">Ord</a>,</div></h4></section></summary><div class=\"docblock\"><p>Sorts the slice, preserving initial order of equal elements.</p>\n<p>This sort is stable (i.e., does not reorder equal elements) and <em>O</em>(<em>n</em> * log(<em>n</em>))\nworst-case.</p>\n<p>If the implementation of <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\"><code>Ord</code></a> for <code>T</code> does not implement a <a href=\"https://en.wikipedia.org/wiki/Total_order\">total order</a>, the function\nmay panic; even if the function exits normally, the resulting order of elements in the slice\nis unspecified. See also the note on panicking below.</p>\n<p>When applicable, unstable sorting is preferred because it is generally faster than stable\nsorting and it doesn’t allocate auxiliary memory. See\n<a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.sort_unstable\" title=\"method slice::sort_unstable\"><code>sort_unstable</code></a>. The exception are partially sorted slices, which\nmay be better served with <code>slice::sort</code>.</p>\n<p>Sorting types that only implement <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html\" title=\"trait core::cmp::PartialOrd\"><code>PartialOrd</code></a> such as <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.f32.html\" title=\"primitive f32\"><code>f32</code></a> and <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.f64.html\" title=\"primitive f64\"><code>f64</code></a> require\nadditional precautions. For example, <code>f32::NAN != f32::NAN</code>, which doesn’t fulfill the\nreflexivity requirement of <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\"><code>Ord</code></a>. By using an alternative comparison function with\n<code>slice::sort_by</code> such as <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.f32.html#method.total_cmp\" title=\"method f32::total_cmp\"><code>f32::total_cmp</code></a> or <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.f64.html#method.total_cmp\" title=\"method f64::total_cmp\"><code>f64::total_cmp</code></a> that defines a <a href=\"https://en.wikipedia.org/wiki/Total_order\">total\norder</a> users can sort slices containing floating-point values. Alternatively, if all values\nin the slice are guaranteed to be in a subset for which <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp\" title=\"method core::cmp::PartialOrd::partial_cmp\"><code>PartialOrd::partial_cmp</code></a> forms a\n<a href=\"https://en.wikipedia.org/wiki/Total_order\">total order</a>, it’s possible to sort the slice with <code>sort_by(|a, b| a.partial_cmp(b).unwrap())</code>.</p>\n<h5 id=\"current-implementation\"><a class=\"doc-anchor\" href=\"#current-implementation\">§</a>Current implementation</h5>\n<p>The current implementation is based on <a href=\"https://github.com/Voultapher/driftsort\">driftsort</a> by Orson Peters and Lukas Bergdoll, which\ncombines the fast average case of quicksort with the fast worst case and partial run\ndetection of mergesort, achieving linear time on fully sorted and reversed inputs. On inputs\nwith k distinct elements, the expected time to sort the data is <em>O</em>(<em>n</em> * log(<em>k</em>)).</p>\n<p>The auxiliary memory allocation behavior depends on the input length. Short slices are\nhandled without allocation, medium sized slices allocate <code>self.len()</code> and beyond that it\nclamps at <code>self.len() / 2</code>.</p>\n<h5 id=\"panics\"><a class=\"doc-anchor\" href=\"#panics\">§</a>Panics</h5>\n<p>May panic if the implementation of <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\"><code>Ord</code></a> for <code>T</code> does not implement a <a href=\"https://en.wikipedia.org/wiki/Total_order\">total order</a>, or if\nthe <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\"><code>Ord</code></a> implementation itself panics.</p>\n<p>All safe functions on slices preserve the invariant that even if the function panics, all\noriginal elements will remain in the slice and any possible modifications via interior\nmutability are observed in the input. This ensures that recovery code (for instance inside\nof a <code>Drop</code> or following a <code>catch_unwind</code>) will still have access to all the original\nelements. For instance, if the slice belongs to a <code>Vec</code>, the <code>Vec::drop</code> method will be able\nto dispose of all contained elements.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v = [<span class=\"number\">4</span>, -<span class=\"number\">5</span>, <span class=\"number\">1</span>, -<span class=\"number\">3</span>, <span class=\"number\">2</span>];\n\nv.sort();\n<span class=\"macro\">assert_eq!</span>(v, [-<span class=\"number\">5</span>, -<span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.sort_by\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/slice.rs.html#297-299\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.sort_by\" class=\"fn\">sort_by</a>&lt;F&gt;(&amp;mut self, compare: F)<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/enum.Ordering.html\" title=\"enum core::cmp::Ordering\">Ordering</a>,</div></h4></section></summary><div class=\"docblock\"><p>Sorts the slice with a comparison function, preserving initial order of equal elements.</p>\n<p>This sort is stable (i.e., does not reorder equal elements) and <em>O</em>(<em>n</em> * log(<em>n</em>))\nworst-case.</p>\n<p>If the comparison function <code>compare</code> does not implement a <a href=\"https://en.wikipedia.org/wiki/Total_order\">total order</a>, the function may\npanic; even if the function exits normally, the resulting order of elements in the slice is\nunspecified. See also the note on panicking below.</p>\n<p>For example <code>|a, b| (a - b).cmp(a)</code> is a comparison function that is neither transitive nor\nreflexive nor total, <code>a &lt; b &lt; c &lt; a</code> with <code>a = 1, b = 2, c = 3</code>. For more information and\nexamples see the <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\"><code>Ord</code></a> documentation.</p>\n<h5 id=\"current-implementation-1\"><a class=\"doc-anchor\" href=\"#current-implementation-1\">§</a>Current implementation</h5>\n<p>The current implementation is based on <a href=\"https://github.com/Voultapher/driftsort\">driftsort</a> by Orson Peters and Lukas Bergdoll, which\ncombines the fast average case of quicksort with the fast worst case and partial run\ndetection of mergesort, achieving linear time on fully sorted and reversed inputs. On inputs\nwith k distinct elements, the expected time to sort the data is <em>O</em>(<em>n</em> * log(<em>k</em>)).</p>\n<p>The auxiliary memory allocation behavior depends on the input length. Short slices are\nhandled without allocation, medium sized slices allocate <code>self.len()</code> and beyond that it\nclamps at <code>self.len() / 2</code>.</p>\n<h5 id=\"panics-1\"><a class=\"doc-anchor\" href=\"#panics-1\">§</a>Panics</h5>\n<p>May panic if <code>compare</code> does not implement a <a href=\"https://en.wikipedia.org/wiki/Total_order\">total order</a>, or if <code>compare</code> itself panics.</p>\n<p>All safe functions on slices preserve the invariant that even if the function panics, all\noriginal elements will remain in the slice and any possible modifications via interior\nmutability are observed in the input. This ensures that recovery code (for instance inside\nof a <code>Drop</code> or following a <code>catch_unwind</code>) will still have access to all the original\nelements. For instance, if the slice belongs to a <code>Vec</code>, the <code>Vec::drop</code> method will be able\nto dispose of all contained elements.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v = [<span class=\"number\">4</span>, -<span class=\"number\">5</span>, <span class=\"number\">1</span>, -<span class=\"number\">3</span>, <span class=\"number\">2</span>];\nv.sort_by(|a, b| a.cmp(b));\n<span class=\"macro\">assert_eq!</span>(v, [-<span class=\"number\">5</span>, -<span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>]);\n\n<span class=\"comment\">// reverse sorting\n</span>v.sort_by(|a, b| b.cmp(a));\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, -<span class=\"number\">3</span>, -<span class=\"number\">5</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.sort_by_key\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.7.0\">1.7.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/slice.rs.html#351-354\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.sort_by_key\" class=\"fn\">sort_by_key</a>&lt;K, F&gt;(&amp;mut self, f: F)<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>) -&gt; K,\n    K: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\">Ord</a>,</div></h4></section></summary><div class=\"docblock\"><p>Sorts the slice with a key extraction function, preserving initial order of equal elements.</p>\n<p>This sort is stable (i.e., does not reorder equal elements) and <em>O</em>(<em>m</em> * <em>n</em> * log(<em>n</em>))\nworst-case, where the key function is <em>O</em>(<em>m</em>).</p>\n<p>If the implementation of <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\"><code>Ord</code></a> for <code>K</code> does not implement a <a href=\"https://en.wikipedia.org/wiki/Total_order\">total order</a>, the function\nmay panic; even if the function exits normally, the resulting order of elements in the slice\nis unspecified. See also the note on panicking below.</p>\n<h5 id=\"current-implementation-2\"><a class=\"doc-anchor\" href=\"#current-implementation-2\">§</a>Current implementation</h5>\n<p>The current implementation is based on <a href=\"https://github.com/Voultapher/driftsort\">driftsort</a> by Orson Peters and Lukas Bergdoll, which\ncombines the fast average case of quicksort with the fast worst case and partial run\ndetection of mergesort, achieving linear time on fully sorted and reversed inputs. On inputs\nwith k distinct elements, the expected time to sort the data is <em>O</em>(<em>n</em> * log(<em>k</em>)).</p>\n<p>The auxiliary memory allocation behavior depends on the input length. Short slices are\nhandled without allocation, medium sized slices allocate <code>self.len()</code> and beyond that it\nclamps at <code>self.len() / 2</code>.</p>\n<h5 id=\"panics-2\"><a class=\"doc-anchor\" href=\"#panics-2\">§</a>Panics</h5>\n<p>May panic if the implementation of <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\"><code>Ord</code></a> for <code>K</code> does not implement a <a href=\"https://en.wikipedia.org/wiki/Total_order\">total order</a>, or if\nthe <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\"><code>Ord</code></a> implementation or the key-function <code>f</code> panics.</p>\n<p>All safe functions on slices preserve the invariant that even if the function panics, all\noriginal elements will remain in the slice and any possible modifications via interior\nmutability are observed in the input. This ensures that recovery code (for instance inside\nof a <code>Drop</code> or following a <code>catch_unwind</code>) will still have access to all the original\nelements. For instance, if the slice belongs to a <code>Vec</code>, the <code>Vec::drop</code> method will be able\nto dispose of all contained elements.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v = [<span class=\"number\">4i32</span>, -<span class=\"number\">5</span>, <span class=\"number\">1</span>, -<span class=\"number\">3</span>, <span class=\"number\">2</span>];\n\nv.sort_by_key(|k| k.abs());\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, -<span class=\"number\">3</span>, <span class=\"number\">4</span>, -<span class=\"number\">5</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.sort_by_cached_key\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.34.0\">1.34.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/slice.rs.html#415-418\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.sort_by_cached_key\" class=\"fn\">sort_by_cached_key</a>&lt;K, F&gt;(&amp;mut self, f: F)<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>) -&gt; K,\n    K: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\">Ord</a>,</div></h4></section></summary><div class=\"docblock\"><p>Sorts the slice with a key extraction function, preserving initial order of equal elements.</p>\n<p>This sort is stable (i.e., does not reorder equal elements) and <em>O</em>(<em>m</em> * <em>n</em> + <em>n</em> *\nlog(<em>n</em>)) worst-case, where the key function is <em>O</em>(<em>m</em>).</p>\n<p>During sorting, the key function is called at most once per element, by using temporary\nstorage to remember the results of key evaluation. The order of calls to the key function is\nunspecified and may change in future versions of the standard library.</p>\n<p>If the implementation of <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\"><code>Ord</code></a> for <code>K</code> does not implement a <a href=\"https://en.wikipedia.org/wiki/Total_order\">total order</a>, the function\nmay panic; even if the function exits normally, the resulting order of elements in the slice\nis unspecified. See also the note on panicking below.</p>\n<p>For simple key functions (e.g., functions that are property accesses or basic operations),\n<a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.sort_by_key\" title=\"method slice::sort_by_key\"><code>sort_by_key</code></a> is likely to be faster.</p>\n<h5 id=\"current-implementation-3\"><a class=\"doc-anchor\" href=\"#current-implementation-3\">§</a>Current implementation</h5>\n<p>The current implementation is based on <a href=\"https://github.com/Voultapher/sort-research-rs/tree/main/ipnsort\">instruction-parallel-network sort</a> by Lukas\nBergdoll, which combines the fast average case of randomized quicksort with the fast worst\ncase of heapsort, while achieving linear time on fully sorted and reversed inputs. And\n<em>O</em>(<em>k</em> * log(<em>n</em>)) where <em>k</em> is the number of distinct elements in the input. It leverages\nsuperscalar out-of-order execution capabilities commonly found in CPUs, to efficiently\nperform the operation.</p>\n<p>In the worst case, the algorithm allocates temporary storage in a <code>Vec&lt;(K, usize)&gt;</code> the\nlength of the slice.</p>\n<h5 id=\"panics-3\"><a class=\"doc-anchor\" href=\"#panics-3\">§</a>Panics</h5>\n<p>May panic if the implementation of <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\"><code>Ord</code></a> for <code>K</code> does not implement a <a href=\"https://en.wikipedia.org/wiki/Total_order\">total order</a>, or if\nthe <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\"><code>Ord</code></a> implementation panics.</p>\n<p>All safe functions on slices preserve the invariant that even if the function panics, all\noriginal elements will remain in the slice and any possible modifications via interior\nmutability are observed in the input. This ensures that recovery code (for instance inside\nof a <code>Drop</code> or following a <code>catch_unwind</code>) will still have access to all the original\nelements. For instance, if the slice belongs to a <code>Vec</code>, the <code>Vec::drop</code> method will be able\nto dispose of all contained elements.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v = [<span class=\"number\">4i32</span>, -<span class=\"number\">5</span>, <span class=\"number\">1</span>, -<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">10</span>];\n\n<span class=\"comment\">// Strings are sorted by lexicographical order.\n</span>v.sort_by_cached_key(|k| k.to_string());\n<span class=\"macro\">assert_eq!</span>(v, [-<span class=\"number\">3</span>, -<span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">10</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.to_vec\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/slice.rs.html#475-477\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.to_vec\" class=\"fn\">to_vec</a>(&amp;self) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>,</div></h4></section></summary><div class=\"docblock\"><p>Copies <code>self</code> into a new <code>Vec</code>.</p>\n<h5 id=\"examples-4\"><a class=\"doc-anchor\" href=\"#examples-4\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = [<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>];\n<span class=\"kw\">let </span>x = s.to_vec();\n<span class=\"comment\">// Here, `s` and `x` can be modified independently.</span></code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.to_vec_in\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/slice.rs.html#499-501\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.to_vec_in\" class=\"fn\">to_vec_in</a>&lt;A&gt;(&amp;self, alloc: A) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/alloc/trait.Allocator.html\" title=\"trait core::alloc::Allocator\">Allocator</a>,\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class=\"docblock\"><p>Copies <code>self</code> into a new <code>Vec</code> with an allocator.</p>\n<h5 id=\"examples-5\"><a class=\"doc-anchor\" href=\"#examples-5\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(allocator_api)]\n\n</span><span class=\"kw\">use </span>std::alloc::System;\n\n<span class=\"kw\">let </span>s = [<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>];\n<span class=\"kw\">let </span>x = s.to_vec_in(System);\n<span class=\"comment\">// Here, `s` and `x` can be modified independently.</span></code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.into_vec\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/slice.rs.html#525\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.into_vec\" class=\"fn\">into_vec</a>&lt;A&gt;(self: <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/boxed/struct.Box.html\" title=\"struct alloc::boxed::Box\">Box</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>, A&gt;) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;T, A&gt;<div class=\"where\">where\n    A: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/alloc/trait.Allocator.html\" title=\"trait core::alloc::Allocator\">Allocator</a>,</div></h4></section></summary><div class=\"docblock\"><p>Converts <code>self</code> into a vector without clones or allocation.</p>\n<p>The resulting vector can be converted back into a box via\n<code>Vec&lt;T&gt;</code>’s <code>into_boxed_slice</code> method.</p>\n<h5 id=\"examples-6\"><a class=\"doc-anchor\" href=\"#examples-6\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s: Box&lt;[i32]&gt; = Box::new([<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>]);\n<span class=\"kw\">let </span>x = s.into_vec();\n<span class=\"comment\">// `s` cannot be used anymore because it has been converted into `x`.\n\n</span><span class=\"macro\">assert_eq!</span>(x, <span class=\"macro\">vec!</span>[<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.repeat\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.40.0\">1.40.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/slice.rs.html#553-555\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.repeat\" class=\"fn\">repeat</a>(&amp;self, n: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/marker/trait.Copy.html\" title=\"trait core::marker::Copy\">Copy</a>,</div></h4></section></summary><div class=\"docblock\"><p>Creates a vector by copying a slice <code>n</code> times.</p>\n<h5 id=\"panics-4\"><a class=\"doc-anchor\" href=\"#panics-4\">§</a>Panics</h5>\n<p>This function will panic if the capacity would overflow.</p>\n<h5 id=\"examples-7\"><a class=\"doc-anchor\" href=\"#examples-7\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>].repeat(<span class=\"number\">3</span>), <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>]);</code></pre></div>\n<p>A panic upon overflow:</p>\n\n<div class=\"example-wrap should_panic\"><a href=\"#\" class=\"tooltip\" title=\"This example panics\">ⓘ</a><pre class=\"rust rust-example-rendered\"><code><span class=\"comment\">// this will panic at runtime\n</span><span class=\"string\">b\"0123456789abcdef\"</span>.repeat(usize::MAX);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.concat\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/slice.rs.html#621-623\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.concat\" class=\"fn\">concat</a>&lt;Item&gt;(&amp;self) -&gt; &lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a> as <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/alloc/slice/trait.Concat.html\" title=\"trait alloc::slice::Concat\">Concat</a>&lt;Item&gt;&gt;::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.85.0/alloc/slice/trait.Concat.html#associatedtype.Output\" title=\"type alloc::slice::Concat::Output\">Output</a> <a href=\"#\" class=\"tooltip\" data-notable-ty=\"&lt;[T] as Concat&lt;Item&gt;&gt;::Output\">ⓘ</a><div class=\"where\">where\n    <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/alloc/slice/trait.Concat.html\" title=\"trait alloc::slice::Concat\">Concat</a>&lt;Item&gt;,\n    Item: ?<a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a>,</div></h4></section></summary><div class=\"docblock\"><p>Flattens a slice of <code>T</code> into a single value <code>Self::Output</code>.</p>\n<h5 id=\"examples-8\"><a class=\"doc-anchor\" href=\"#examples-8\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>([<span class=\"string\">\"hello\"</span>, <span class=\"string\">\"world\"</span>].concat(), <span class=\"string\">\"helloworld\"</span>);\n<span class=\"macro\">assert_eq!</span>([[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]].concat(), [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.join\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.3.0\">1.3.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/slice.rs.html#640-642\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.join\" class=\"fn\">join</a>&lt;Separator&gt;(\n    &amp;self,\n    sep: Separator,\n) -&gt; &lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a> as <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/alloc/slice/trait.Join.html\" title=\"trait alloc::slice::Join\">Join</a>&lt;Separator&gt;&gt;::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.85.0/alloc/slice/trait.Join.html#associatedtype.Output\" title=\"type alloc::slice::Join::Output\">Output</a> <a href=\"#\" class=\"tooltip\" data-notable-ty=\"&lt;[T] as Join&lt;Separator&gt;&gt;::Output\">ⓘ</a><div class=\"where\">where\n    <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/alloc/slice/trait.Join.html\" title=\"trait alloc::slice::Join\">Join</a>&lt;Separator&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Flattens a slice of <code>T</code> into a single value <code>Self::Output</code>, placing a\ngiven separator between each.</p>\n<h5 id=\"examples-9\"><a class=\"doc-anchor\" href=\"#examples-9\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>([<span class=\"string\">\"hello\"</span>, <span class=\"string\">\"world\"</span>].join(<span class=\"string\">\" \"</span>), <span class=\"string\">\"hello world\"</span>);\n<span class=\"macro\">assert_eq!</span>([[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]].join(<span class=\"kw-2\">&amp;</span><span class=\"number\">0</span>), [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]);\n<span class=\"macro\">assert_eq!</span>([[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]].join(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">0</span>, <span class=\"number\">0</span>][..]), [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.connect\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/slice.rs.html#660-662\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.connect\" class=\"fn\">connect</a>&lt;Separator&gt;(\n    &amp;self,\n    sep: Separator,\n) -&gt; &lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a> as <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/alloc/slice/trait.Join.html\" title=\"trait alloc::slice::Join\">Join</a>&lt;Separator&gt;&gt;::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.85.0/alloc/slice/trait.Join.html#associatedtype.Output\" title=\"type alloc::slice::Join::Output\">Output</a> <a href=\"#\" class=\"tooltip\" data-notable-ty=\"&lt;[T] as Join&lt;Separator&gt;&gt;::Output\">ⓘ</a><div class=\"where\">where\n    <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/alloc/slice/trait.Join.html\" title=\"trait alloc::slice::Join\">Join</a>&lt;Separator&gt;,</div></h4></section><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">👎</span><span>Deprecated since 1.3.0: renamed to join</span></div></span></summary><div class=\"docblock\"><p>Flattens a slice of <code>T</code> into a single value <code>Self::Output</code>, placing a\ngiven separator between each.</p>\n<h5 id=\"examples-10\"><a class=\"doc-anchor\" href=\"#examples-10\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>([<span class=\"string\">\"hello\"</span>, <span class=\"string\">\"world\"</span>].connect(<span class=\"string\">\" \"</span>), <span class=\"string\">\"hello world\"</span>);\n<span class=\"macro\">assert_eq!</span>([[<span class=\"number\">1</span>, <span class=\"number\">2</span>], [<span class=\"number\">3</span>, <span class=\"number\">4</span>]].connect(<span class=\"kw-2\">&amp;</span><span class=\"number\">0</span>), [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]);</code></pre></div>\n</div></details></div></details>",0,"retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-%5BT%5D\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#103\">Source</a><a href=\"#impl-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.len\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const since 1.39.0\">1.0.0 (const: 1.39.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#117\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.len\" class=\"fn\">len</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a></h4></section></summary><div class=\"docblock\"><p>Returns the number of elements in the slice.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"macro\">assert_eq!</span>(a.len(), <span class=\"number\">3</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_empty\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const since 1.39.0\">1.0.0 (const: 1.39.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#136\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.is_empty\" class=\"fn\">is_empty</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if the slice has a length of 0.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"macro\">assert!</span>(!a.is_empty());\n\n<span class=\"kw\">let </span>b: <span class=\"kw-2\">&amp;</span>[i32] = <span class=\"kw-2\">&amp;</span>[];\n<span class=\"macro\">assert!</span>(b.is_empty());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.first\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const since 1.56.0\">1.0.0 (const: 1.56.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#155\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.first\" class=\"fn\">first</a>(&amp;self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Returns the first element of the slice, or <code>None</code> if it is empty.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = [<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>];\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">10</span>), v.first());\n\n<span class=\"kw\">let </span>w: <span class=\"kw-2\">&amp;</span>[i32] = <span class=\"kw-2\">&amp;</span>[];\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, w.first());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.first_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const since 1.83.0\">1.0.0 (const: 1.83.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#178\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.first_mut\" class=\"fn\">first_mut</a>(&amp;mut self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;mut T</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Returns a mutable reference to the first element of the slice, or <code>None</code> if it is empty.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];\n\n<span class=\"kw\">if let </span><span class=\"prelude-val\">Some</span>(first) = x.first_mut() {\n    <span class=\"kw-2\">*</span>first = <span class=\"number\">5</span>;\n}\n<span class=\"macro\">assert_eq!</span>(x, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>]);\n\n<span class=\"kw\">let </span>y: <span class=\"kw-2\">&amp;mut </span>[i32] = <span class=\"kw-2\">&amp;mut </span>[];\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, y.first_mut());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.split_first\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.5.0, const since 1.56.0\">1.5.0 (const: 1.56.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#198\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.split_first\" class=\"fn\">split_first</a>(&amp;self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>, &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)&gt;</h4></section></summary><div class=\"docblock\"><p>Returns the first and all the rest of the elements of the slice, or <code>None</code> if it is empty.</p>\n<h5 id=\"examples-4\"><a class=\"doc-anchor\" href=\"#examples-4\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];\n\n<span class=\"kw\">if let </span><span class=\"prelude-val\">Some</span>((first, elements)) = x.split_first() {\n    <span class=\"macro\">assert_eq!</span>(first, <span class=\"kw-2\">&amp;</span><span class=\"number\">0</span>);\n    <span class=\"macro\">assert_eq!</span>(elements, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>]);\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.split_first_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.5.0, const since 1.83.0\">1.5.0 (const: 1.83.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#220\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.split_first_mut\" class=\"fn\">split_first_mut</a>(&amp;mut self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;mut T</a>, &amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)&gt;</h4></section></summary><div class=\"docblock\"><p>Returns the first and all the rest of the elements of the slice, or <code>None</code> if it is empty.</p>\n<h5 id=\"examples-5\"><a class=\"doc-anchor\" href=\"#examples-5\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];\n\n<span class=\"kw\">if let </span><span class=\"prelude-val\">Some</span>((first, elements)) = x.split_first_mut() {\n    <span class=\"kw-2\">*</span>first = <span class=\"number\">3</span>;\n    elements[<span class=\"number\">0</span>] = <span class=\"number\">4</span>;\n    elements[<span class=\"number\">1</span>] = <span class=\"number\">5</span>;\n}\n<span class=\"macro\">assert_eq!</span>(x, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.split_last\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.5.0, const since 1.56.0\">1.5.0 (const: 1.56.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#240\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.split_last\" class=\"fn\">split_last</a>(&amp;self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>, &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)&gt;</h4></section></summary><div class=\"docblock\"><p>Returns the last and all the rest of the elements of the slice, or <code>None</code> if it is empty.</p>\n<h5 id=\"examples-6\"><a class=\"doc-anchor\" href=\"#examples-6\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];\n\n<span class=\"kw\">if let </span><span class=\"prelude-val\">Some</span>((last, elements)) = x.split_last() {\n    <span class=\"macro\">assert_eq!</span>(last, <span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>);\n    <span class=\"macro\">assert_eq!</span>(elements, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>]);\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.split_last_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.5.0, const since 1.83.0\">1.5.0 (const: 1.83.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#262\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.split_last_mut\" class=\"fn\">split_last_mut</a>(&amp;mut self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;mut T</a>, &amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)&gt;</h4></section></summary><div class=\"docblock\"><p>Returns the last and all the rest of the elements of the slice, or <code>None</code> if it is empty.</p>\n<h5 id=\"examples-7\"><a class=\"doc-anchor\" href=\"#examples-7\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];\n\n<span class=\"kw\">if let </span><span class=\"prelude-val\">Some</span>((last, elements)) = x.split_last_mut() {\n    <span class=\"kw-2\">*</span>last = <span class=\"number\">3</span>;\n    elements[<span class=\"number\">0</span>] = <span class=\"number\">4</span>;\n    elements[<span class=\"number\">1</span>] = <span class=\"number\">5</span>;\n}\n<span class=\"macro\">assert_eq!</span>(x, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.last\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const since 1.56.0\">1.0.0 (const: 1.56.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#281\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.last\" class=\"fn\">last</a>(&amp;self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Returns the last element of the slice, or <code>None</code> if it is empty.</p>\n<h5 id=\"examples-8\"><a class=\"doc-anchor\" href=\"#examples-8\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = [<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>];\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">30</span>), v.last());\n\n<span class=\"kw\">let </span>w: <span class=\"kw-2\">&amp;</span>[i32] = <span class=\"kw-2\">&amp;</span>[];\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, w.last());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.last_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const since 1.83.0\">1.0.0 (const: 1.83.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#304\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.last_mut\" class=\"fn\">last_mut</a>(&amp;mut self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;mut T</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Returns a mutable reference to the last item in the slice, or <code>None</code> if it is empty.</p>\n<h5 id=\"examples-9\"><a class=\"doc-anchor\" href=\"#examples-9\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];\n\n<span class=\"kw\">if let </span><span class=\"prelude-val\">Some</span>(last) = x.last_mut() {\n    <span class=\"kw-2\">*</span>last = <span class=\"number\">10</span>;\n}\n<span class=\"macro\">assert_eq!</span>(x, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">10</span>]);\n\n<span class=\"kw\">let </span>y: <span class=\"kw-2\">&amp;mut </span>[i32] = <span class=\"kw-2\">&amp;mut </span>[];\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, y.last_mut());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.first_chunk\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.77.0, const since 1.77.0\">1.77.0 (const: 1.77.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#327\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.first_chunk\" class=\"fn\">first_chunk</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;(&amp;self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;&amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.array.html\">[T; N]</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Returns an array reference to the first <code>N</code> items in the slice.</p>\n<p>If the slice is not at least <code>N</code> in length, this will return <code>None</code>.</p>\n<h5 id=\"examples-10\"><a class=\"doc-anchor\" href=\"#examples-10\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>u = [<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>];\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">10</span>, <span class=\"number\">40</span>]), u.first_chunk::&lt;<span class=\"number\">2</span>&gt;());\n\n<span class=\"kw\">let </span>v: <span class=\"kw-2\">&amp;</span>[i32] = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">10</span>];\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, v.first_chunk::&lt;<span class=\"number\">2</span>&gt;());\n\n<span class=\"kw\">let </span>w: <span class=\"kw-2\">&amp;</span>[i32] = <span class=\"kw-2\">&amp;</span>[];\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span>[]), w.first_chunk::&lt;<span class=\"number\">0</span>&gt;());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.first_chunk_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.77.0, const since 1.83.0\">1.77.0 (const: 1.83.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#357\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.first_chunk_mut\" class=\"fn\">first_chunk_mut</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;(&amp;mut self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;&amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.array.html\">[T; N]</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Returns a mutable array reference to the first <code>N</code> items in the slice.</p>\n<p>If the slice is not at least <code>N</code> in length, this will return <code>None</code>.</p>\n<h5 id=\"examples-11\"><a class=\"doc-anchor\" href=\"#examples-11\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];\n\n<span class=\"kw\">if let </span><span class=\"prelude-val\">Some</span>(first) = x.first_chunk_mut::&lt;<span class=\"number\">2</span>&gt;() {\n    first[<span class=\"number\">0</span>] = <span class=\"number\">5</span>;\n    first[<span class=\"number\">1</span>] = <span class=\"number\">4</span>;\n}\n<span class=\"macro\">assert_eq!</span>(x, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>]);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, x.first_chunk_mut::&lt;<span class=\"number\">4</span>&gt;());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.split_first_chunk\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.77.0, const since 1.77.0\">1.77.0 (const: 1.77.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#387\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.split_first_chunk\" class=\"fn\">split_first_chunk</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;(&amp;self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;(&amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.array.html\">[T; N]</a>, &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)&gt;</h4></section></summary><div class=\"docblock\"><p>Returns an array reference to the first <code>N</code> items in the slice and the remaining slice.</p>\n<p>If the slice is not at least <code>N</code> in length, this will return <code>None</code>.</p>\n<h5 id=\"examples-12\"><a class=\"doc-anchor\" href=\"#examples-12\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];\n\n<span class=\"kw\">if let </span><span class=\"prelude-val\">Some</span>((first, elements)) = x.split_first_chunk::&lt;<span class=\"number\">2</span>&gt;() {\n    <span class=\"macro\">assert_eq!</span>(first, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>]);\n    <span class=\"macro\">assert_eq!</span>(elements, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">2</span>]);\n}\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, x.split_first_chunk::&lt;<span class=\"number\">4</span>&gt;());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.split_first_chunk_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.77.0, const since 1.83.0\">1.77.0 (const: 1.83.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#422-424\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.split_first_chunk_mut\" class=\"fn\">split_first_chunk_mut</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;(\n    &amp;mut self,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;(&amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.array.html\">[T; N]</a>, &amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)&gt;</h4></section></summary><div class=\"docblock\"><p>Returns a mutable array reference to the first <code>N</code> items in the slice and the remaining\nslice.</p>\n<p>If the slice is not at least <code>N</code> in length, this will return <code>None</code>.</p>\n<h5 id=\"examples-13\"><a class=\"doc-anchor\" href=\"#examples-13\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];\n\n<span class=\"kw\">if let </span><span class=\"prelude-val\">Some</span>((first, elements)) = x.split_first_chunk_mut::&lt;<span class=\"number\">2</span>&gt;() {\n    first[<span class=\"number\">0</span>] = <span class=\"number\">3</span>;\n    first[<span class=\"number\">1</span>] = <span class=\"number\">4</span>;\n    elements[<span class=\"number\">0</span>] = <span class=\"number\">5</span>;\n}\n<span class=\"macro\">assert_eq!</span>(x, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, x.split_first_chunk_mut::&lt;<span class=\"number\">4</span>&gt;());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.split_last_chunk\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.77.0, const since 1.77.0\">1.77.0 (const: 1.77.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#457\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.split_last_chunk\" class=\"fn\">split_last_chunk</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;(&amp;self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;(&amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>, &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.array.html\">[T; N]</a>)&gt;</h4></section></summary><div class=\"docblock\"><p>Returns an array reference to the last <code>N</code> items in the slice and the remaining slice.</p>\n<p>If the slice is not at least <code>N</code> in length, this will return <code>None</code>.</p>\n<h5 id=\"examples-14\"><a class=\"doc-anchor\" href=\"#examples-14\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];\n\n<span class=\"kw\">if let </span><span class=\"prelude-val\">Some</span>((elements, last)) = x.split_last_chunk::&lt;<span class=\"number\">2</span>&gt;() {\n    <span class=\"macro\">assert_eq!</span>(elements, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0</span>]);\n    <span class=\"macro\">assert_eq!</span>(last, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>]);\n}\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, x.split_last_chunk::&lt;<span class=\"number\">4</span>&gt;());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.split_last_chunk_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.77.0, const since 1.83.0\">1.77.0 (const: 1.83.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#492-494\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.split_last_chunk_mut\" class=\"fn\">split_last_chunk_mut</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;(\n    &amp;mut self,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;(&amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>, &amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.array.html\">[T; N]</a>)&gt;</h4></section></summary><div class=\"docblock\"><p>Returns a mutable array reference to the last <code>N</code> items in the slice and the remaining\nslice.</p>\n<p>If the slice is not at least <code>N</code> in length, this will return <code>None</code>.</p>\n<h5 id=\"examples-15\"><a class=\"doc-anchor\" href=\"#examples-15\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];\n\n<span class=\"kw\">if let </span><span class=\"prelude-val\">Some</span>((elements, last)) = x.split_last_chunk_mut::&lt;<span class=\"number\">2</span>&gt;() {\n    last[<span class=\"number\">0</span>] = <span class=\"number\">3</span>;\n    last[<span class=\"number\">1</span>] = <span class=\"number\">4</span>;\n    elements[<span class=\"number\">0</span>] = <span class=\"number\">5</span>;\n}\n<span class=\"macro\">assert_eq!</span>(x, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, x.split_last_chunk_mut::&lt;<span class=\"number\">4</span>&gt;());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.last_chunk\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.77.0, const since 1.80.0\">1.77.0 (const: 1.80.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#527\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.last_chunk\" class=\"fn\">last_chunk</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;(&amp;self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;&amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.array.html\">[T; N]</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Returns an array reference to the last <code>N</code> items in the slice.</p>\n<p>If the slice is not at least <code>N</code> in length, this will return <code>None</code>.</p>\n<h5 id=\"examples-16\"><a class=\"doc-anchor\" href=\"#examples-16\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>u = [<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>];\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">40</span>, <span class=\"number\">30</span>]), u.last_chunk::&lt;<span class=\"number\">2</span>&gt;());\n\n<span class=\"kw\">let </span>v: <span class=\"kw-2\">&amp;</span>[i32] = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">10</span>];\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, v.last_chunk::&lt;<span class=\"number\">2</span>&gt;());\n\n<span class=\"kw\">let </span>w: <span class=\"kw-2\">&amp;</span>[i32] = <span class=\"kw-2\">&amp;</span>[];\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span>[]), w.last_chunk::&lt;<span class=\"number\">0</span>&gt;());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.last_chunk_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.77.0, const since 1.83.0\">1.77.0 (const: 1.83.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#561\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.last_chunk_mut\" class=\"fn\">last_chunk_mut</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;(&amp;mut self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;&amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.array.html\">[T; N]</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Returns a mutable array reference to the last <code>N</code> items in the slice.</p>\n<p>If the slice is not at least <code>N</code> in length, this will return <code>None</code>.</p>\n<h5 id=\"examples-17\"><a class=\"doc-anchor\" href=\"#examples-17\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];\n\n<span class=\"kw\">if let </span><span class=\"prelude-val\">Some</span>(last) = x.last_chunk_mut::&lt;<span class=\"number\">2</span>&gt;() {\n    last[<span class=\"number\">0</span>] = <span class=\"number\">10</span>;\n    last[<span class=\"number\">1</span>] = <span class=\"number\">20</span>;\n}\n<span class=\"macro\">assert_eq!</span>(x, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0</span>, <span class=\"number\">10</span>, <span class=\"number\">20</span>]);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, x.last_chunk_mut::&lt;<span class=\"number\">4</span>&gt;());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#596-598\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.get\" class=\"fn\">get</a>&lt;I&gt;(&amp;self, index: I) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;&amp;&lt;I as <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/index/trait.SliceIndex.html\" title=\"trait core::slice::index::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>&gt;&gt;::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/index/trait.SliceIndex.html#associatedtype.Output\" title=\"type core::slice::index::SliceIndex::Output\">Output</a>&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/index/trait.SliceIndex.html\" title=\"trait core::slice::index::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Returns a reference to an element or subslice depending on the type of\nindex.</p>\n<ul>\n<li>If given a position, returns a reference to the element at that\nposition or <code>None</code> if out of bounds.</li>\n<li>If given a range, returns the subslice corresponding to that range,\nor <code>None</code> if out of bounds.</li>\n</ul>\n<h5 id=\"examples-18\"><a class=\"doc-anchor\" href=\"#examples-18\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = [<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>];\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">40</span>), v.get(<span class=\"number\">1</span>));\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">10</span>, <span class=\"number\">40</span>][..]), v.get(<span class=\"number\">0</span>..<span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, v.get(<span class=\"number\">3</span>));\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, v.get(<span class=\"number\">0</span>..<span class=\"number\">4</span>));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#621-623\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.get_mut\" class=\"fn\">get_mut</a>&lt;I&gt;(\n    &amp;mut self,\n    index: I,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;&amp;mut &lt;I as <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/index/trait.SliceIndex.html\" title=\"trait core::slice::index::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>&gt;&gt;::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/index/trait.SliceIndex.html#associatedtype.Output\" title=\"type core::slice::index::SliceIndex::Output\">Output</a>&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/index/trait.SliceIndex.html\" title=\"trait core::slice::index::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Returns a mutable reference to an element or subslice depending on the\ntype of index (see <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.get\" title=\"method slice::get\"><code>get</code></a>) or <code>None</code> if the index is out of bounds.</p>\n<h5 id=\"examples-19\"><a class=\"doc-anchor\" href=\"#examples-19\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];\n\n<span class=\"kw\">if let </span><span class=\"prelude-val\">Some</span>(elem) = x.get_mut(<span class=\"number\">1</span>) {\n    <span class=\"kw-2\">*</span>elem = <span class=\"number\">42</span>;\n}\n<span class=\"macro\">assert_eq!</span>(x, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0</span>, <span class=\"number\">42</span>, <span class=\"number\">2</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_unchecked\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#658-660\">Source</a></span><h4 class=\"code-header\">pub unsafe fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.get_unchecked\" class=\"fn\">get_unchecked</a>&lt;I&gt;(\n    &amp;self,\n    index: I,\n) -&gt; &amp;&lt;I as <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/index/trait.SliceIndex.html\" title=\"trait core::slice::index::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>&gt;&gt;::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/index/trait.SliceIndex.html#associatedtype.Output\" title=\"type core::slice::index::SliceIndex::Output\">Output</a><div class=\"where\">where\n    I: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/index/trait.SliceIndex.html\" title=\"trait core::slice::index::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Returns a reference to an element or subslice, without doing bounds\nchecking.</p>\n<p>For a safe alternative see <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.get\" title=\"method slice::get\"><code>get</code></a>.</p>\n<h5 id=\"safety\"><a class=\"doc-anchor\" href=\"#safety\">§</a>Safety</h5>\n<p>Calling this method with an out-of-bounds index is <em><a href=\"https://doc.rust-lang.org/reference/behavior-considered-undefined.html\">undefined behavior</a></em>\neven if the resulting reference is not used.</p>\n<p>You can think of this like <code>.get(index).unwrap_unchecked()</code>.  It’s UB\nto call <code>.get_unchecked(len)</code>, even if you immediately convert to a\npointer.  And it’s UB to call <code>.get_unchecked(..len + 1)</code>,\n<code>.get_unchecked(..=len)</code>, or similar.</p>\n<h5 id=\"examples-20\"><a class=\"doc-anchor\" href=\"#examples-20\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>];\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"macro\">assert_eq!</span>(x.get_unchecked(<span class=\"number\">1</span>), <span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>);\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_unchecked_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#700-702\">Source</a></span><h4 class=\"code-header\">pub unsafe fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.get_unchecked_mut\" class=\"fn\">get_unchecked_mut</a>&lt;I&gt;(\n    &amp;mut self,\n    index: I,\n) -&gt; &amp;mut &lt;I as <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/index/trait.SliceIndex.html\" title=\"trait core::slice::index::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>&gt;&gt;::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/index/trait.SliceIndex.html#associatedtype.Output\" title=\"type core::slice::index::SliceIndex::Output\">Output</a><div class=\"where\">where\n    I: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/index/trait.SliceIndex.html\" title=\"trait core::slice::index::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Returns a mutable reference to an element or subslice, without doing\nbounds checking.</p>\n<p>For a safe alternative see <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.get_mut\" title=\"method slice::get_mut\"><code>get_mut</code></a>.</p>\n<h5 id=\"safety-1\"><a class=\"doc-anchor\" href=\"#safety-1\">§</a>Safety</h5>\n<p>Calling this method with an out-of-bounds index is <em><a href=\"https://doc.rust-lang.org/reference/behavior-considered-undefined.html\">undefined behavior</a></em>\neven if the resulting reference is not used.</p>\n<p>You can think of this like <code>.get_mut(index).unwrap_unchecked()</code>.  It’s\nUB to call <code>.get_unchecked_mut(len)</code>, even if you immediately convert\nto a pointer.  And it’s UB to call <code>.get_unchecked_mut(..len + 1)</code>,\n<code>.get_unchecked_mut(..=len)</code>, or similar.</p>\n<h5 id=\"examples-21\"><a class=\"doc-anchor\" href=\"#examples-21\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>];\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>elem = x.get_unchecked_mut(<span class=\"number\">1</span>);\n    <span class=\"kw-2\">*</span>elem = <span class=\"number\">13</span>;\n}\n<span class=\"macro\">assert_eq!</span>(x, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">13</span>, <span class=\"number\">4</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_ptr\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const since 1.32.0\">1.0.0 (const: 1.32.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#742\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.as_ptr\" class=\"fn\">as_ptr</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.pointer.html\">*const T</a></h4></section></summary><div class=\"docblock\"><p>Returns a raw pointer to the slice’s buffer.</p>\n<p>The caller must ensure that the slice outlives the pointer this\nfunction returns, or else it will end up dangling.</p>\n<p>The caller must also ensure that the memory the pointer (non-transitively) points to\nis never written to (except inside an <code>UnsafeCell</code>) using this pointer or any pointer\nderived from it. If you need to mutate the contents of the slice, use <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.as_mut_ptr\" title=\"method slice::as_mut_ptr\"><code>as_mut_ptr</code></a>.</p>\n<p>Modifying the container referenced by this slice may cause its buffer\nto be reallocated, which would also make any pointers to it invalid.</p>\n<h5 id=\"examples-22\"><a class=\"doc-anchor\" href=\"#examples-22\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>];\n<span class=\"kw\">let </span>x_ptr = x.as_ptr();\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">for </span>i <span class=\"kw\">in </span><span class=\"number\">0</span>..x.len() {\n        <span class=\"macro\">assert_eq!</span>(x.get_unchecked(i), <span class=\"kw-2\">&amp;*</span>x_ptr.add(i));\n    }\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_mut_ptr\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const since 1.61.0\">1.0.0 (const: 1.61.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#773\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.as_mut_ptr\" class=\"fn\">as_mut_ptr</a>(&amp;mut self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.pointer.html\">*mut T</a></h4></section></summary><div class=\"docblock\"><p>Returns an unsafe mutable pointer to the slice’s buffer.</p>\n<p>The caller must ensure that the slice outlives the pointer this\nfunction returns, or else it will end up dangling.</p>\n<p>Modifying the container referenced by this slice may cause its buffer\nto be reallocated, which would also make any pointers to it invalid.</p>\n<h5 id=\"examples-23\"><a class=\"doc-anchor\" href=\"#examples-23\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>];\n<span class=\"kw\">let </span>x_ptr = x.as_mut_ptr();\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">for </span>i <span class=\"kw\">in </span><span class=\"number\">0</span>..x.len() {\n        <span class=\"kw-2\">*</span>x_ptr.add(i) += <span class=\"number\">2</span>;\n    }\n}\n<span class=\"macro\">assert_eq!</span>(x, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_ptr_range\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.48.0, const since 1.61.0\">1.48.0 (const: 1.61.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#809\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.as_ptr_range\" class=\"fn\">as_ptr_range</a>(&amp;self) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/range/struct.Range.html\" title=\"struct core::ops::range::Range\">Range</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.pointer.html\">*const T</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Returns the two raw pointers spanning the slice.</p>\n<p>The returned range is half-open, which means that the end pointer\npoints <em>one past</em> the last element of the slice. This way, an empty\nslice is represented by two equal pointers, and the difference between\nthe two pointers represents the size of the slice.</p>\n<p>See <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.as_ptr\" title=\"method slice::as_ptr\"><code>as_ptr</code></a> for warnings on using these pointers. The end pointer\nrequires extra caution, as it does not point to a valid element in the\nslice.</p>\n<p>This function is useful for interacting with foreign interfaces which\nuse two pointers to refer to a range of elements in memory, as is\ncommon in C++.</p>\n<p>It can also be useful to check if a pointer to an element refers to an\nelement of this slice:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"kw\">let </span>x = <span class=\"kw-2\">&amp;</span>a[<span class=\"number\">1</span>] <span class=\"kw\">as </span><span class=\"kw-2\">*const </span><span class=\"kw\">_</span>;\n<span class=\"kw\">let </span>y = <span class=\"kw-2\">&amp;</span><span class=\"number\">5 </span><span class=\"kw\">as </span><span class=\"kw-2\">*const </span><span class=\"kw\">_</span>;\n\n<span class=\"macro\">assert!</span>(a.as_ptr_range().contains(<span class=\"kw-2\">&amp;</span>x));\n<span class=\"macro\">assert!</span>(!a.as_ptr_range().contains(<span class=\"kw-2\">&amp;</span>y));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_mut_ptr_range\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.48.0, const since 1.61.0\">1.48.0 (const: 1.61.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#852\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.as_mut_ptr_range\" class=\"fn\">as_mut_ptr_range</a>(&amp;mut self) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/range/struct.Range.html\" title=\"struct core::ops::range::Range\">Range</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.pointer.html\">*mut T</a>&gt;</h4></section></summary><div class=\"docblock\"><p>Returns the two unsafe mutable pointers spanning the slice.</p>\n<p>The returned range is half-open, which means that the end pointer\npoints <em>one past</em> the last element of the slice. This way, an empty\nslice is represented by two equal pointers, and the difference between\nthe two pointers represents the size of the slice.</p>\n<p>See <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.as_mut_ptr\" title=\"method slice::as_mut_ptr\"><code>as_mut_ptr</code></a> for warnings on using these pointers. The end\npointer requires extra caution, as it does not point to a valid element\nin the slice.</p>\n<p>This function is useful for interacting with foreign interfaces which\nuse two pointers to refer to a range of elements in memory, as is\ncommon in C++.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_array\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#865\">Source</a><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.as_array\" class=\"fn\">as_array</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;(&amp;self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;&amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.array.html\">[T; N]</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_as_array</code>)</span></div></span></summary><div class=\"docblock\"><p>Gets a reference to the underlying array.</p>\n<p>If <code>N</code> is not exactly equal to the length of <code>self</code>, then this method returns <code>None</code>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_mut_array\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#883\">Source</a><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.as_mut_array\" class=\"fn\">as_mut_array</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;(&amp;mut self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;&amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.array.html\">[T; N]</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_as_array</code>)</span></div></span></summary><div class=\"docblock\"><p>Gets a mutable reference to the slice’s underlying array.</p>\n<p>If <code>N</code> is not exactly equal to the length of <code>self</code>, then this method returns <code>None</code>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.swap\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const since 1.85.0\">1.0.0 (const: 1.85.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#919\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.swap\" class=\"fn\">swap</a>(&amp;mut self, a: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>, b: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>)</h4></section></summary><div class=\"docblock\"><p>Swaps two elements in the slice.</p>\n<p>If <code>a</code> equals to <code>b</code>, it’s guaranteed that elements won’t change value.</p>\n<h5 id=\"arguments\"><a class=\"doc-anchor\" href=\"#arguments\">§</a>Arguments</h5>\n<ul>\n<li>a - The index of the first element</li>\n<li>b - The index of the second element</li>\n</ul>\n<h5 id=\"panics\"><a class=\"doc-anchor\" href=\"#panics\">§</a>Panics</h5>\n<p>Panics if <code>a</code> or <code>b</code> are out of bounds.</p>\n<h5 id=\"examples-24\"><a class=\"doc-anchor\" href=\"#examples-24\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v = [<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>, <span class=\"string\">\"e\"</span>];\nv.swap(<span class=\"number\">2</span>, <span class=\"number\">4</span>);\n<span class=\"macro\">assert!</span>(v == [<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"e\"</span>, <span class=\"string\">\"d\"</span>, <span class=\"string\">\"c\"</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.swap_unchecked\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#962\">Source</a><h4 class=\"code-header\">pub const unsafe fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.swap_unchecked\" class=\"fn\">swap_unchecked</a>(&amp;mut self, a: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>, b: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>)</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_swap_unchecked</code>)</span></div></span></summary><div class=\"docblock\"><p>Swaps two elements in the slice, without doing bounds checking.</p>\n<p>For a safe alternative see <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.swap\" title=\"method slice::swap\"><code>swap</code></a>.</p>\n<h5 id=\"arguments-1\"><a class=\"doc-anchor\" href=\"#arguments-1\">§</a>Arguments</h5>\n<ul>\n<li>a - The index of the first element</li>\n<li>b - The index of the second element</li>\n</ul>\n<h5 id=\"safety-2\"><a class=\"doc-anchor\" href=\"#safety-2\">§</a>Safety</h5>\n<p>Calling this method with an out-of-bounds index is <em><a href=\"https://doc.rust-lang.org/reference/behavior-considered-undefined.html\">undefined behavior</a></em>.\nThe caller has to ensure that <code>a &lt; self.len()</code> and <code>b &lt; self.len()</code>.</p>\n<h5 id=\"examples-25\"><a class=\"doc-anchor\" href=\"#examples-25\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(slice_swap_unchecked)]\n\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v = [<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"d\"</span>];\n<span class=\"comment\">// SAFETY: we know that 1 and 3 are both indices of the slice\n</span><span class=\"kw\">unsafe </span>{ v.swap_unchecked(<span class=\"number\">1</span>, <span class=\"number\">3</span>) };\n<span class=\"macro\">assert!</span>(v == [<span class=\"string\">\"a\"</span>, <span class=\"string\">\"d\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"b\"</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.reverse\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#991\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.reverse\" class=\"fn\">reverse</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Reverses the order of elements in the slice, in place.</p>\n<h5 id=\"examples-26\"><a class=\"doc-anchor\" href=\"#examples-26\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\nv.reverse();\n<span class=\"macro\">assert!</span>(v == [<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.iter\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#1050\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.iter\" class=\"fn\">iter</a>(&amp;self) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/iter/struct.Iter.html\" title=\"struct core::slice::iter::Iter\">Iter</a>&lt;'_, T&gt;</h4></section></summary><div class=\"docblock\"><p>Returns an iterator over the slice.</p>\n<p>The iterator yields all items from start to end.</p>\n<h5 id=\"examples-27\"><a class=\"doc-anchor\" href=\"#examples-27\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iterator = x.iter();\n\n<span class=\"macro\">assert_eq!</span>(iterator.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>));\n<span class=\"macro\">assert_eq!</span>(iterator.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">2</span>));\n<span class=\"macro\">assert_eq!</span>(iterator.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span><span class=\"number\">4</span>));\n<span class=\"macro\">assert_eq!</span>(iterator.next(), <span class=\"prelude-val\">None</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.iter_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#1069\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.iter_mut\" class=\"fn\">iter_mut</a>(&amp;mut self) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/iter/struct.IterMut.html\" title=\"struct core::slice::iter::IterMut\">IterMut</a>&lt;'_, T&gt;</h4></section></summary><div class=\"docblock\"><p>Returns an iterator that allows modifying each value.</p>\n<p>The iterator yields all items from start to end.</p>\n<h5 id=\"examples-28\"><a class=\"doc-anchor\" href=\"#examples-28\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>x = <span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>];\n<span class=\"kw\">for </span>elem <span class=\"kw\">in </span>x.iter_mut() {\n    <span class=\"kw-2\">*</span>elem += <span class=\"number\">2</span>;\n}\n<span class=\"macro\">assert_eq!</span>(x, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.windows\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#1118\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.windows\" class=\"fn\">windows</a>(&amp;self, size: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/iter/struct.Windows.html\" title=\"struct core::slice::iter::Windows\">Windows</a>&lt;'_, T&gt;</h4></section></summary><div class=\"docblock\"><p>Returns an iterator over all contiguous windows of length\n<code>size</code>. The windows overlap. If the slice is shorter than\n<code>size</code>, the iterator returns no values.</p>\n<h5 id=\"panics-1\"><a class=\"doc-anchor\" href=\"#panics-1\">§</a>Panics</h5>\n<p>Panics if <code>size</code> is zero.</p>\n<h5 id=\"examples-29\"><a class=\"doc-anchor\" href=\"#examples-29\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>slice = [<span class=\"string\">'l'</span>, <span class=\"string\">'o'</span>, <span class=\"string\">'r'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'m'</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = slice.windows(<span class=\"number\">3</span>);\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'l'</span>, <span class=\"string\">'o'</span>, <span class=\"string\">'r'</span>]);\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'o'</span>, <span class=\"string\">'r'</span>, <span class=\"string\">'e'</span>]);\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'r'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'m'</span>]);\n<span class=\"macro\">assert!</span>(iter.next().is_none());</code></pre></div>\n<p>If the slice is shorter than <code>size</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>slice = [<span class=\"string\">'f'</span>, <span class=\"string\">'o'</span>, <span class=\"string\">'o'</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = slice.windows(<span class=\"number\">4</span>);\n<span class=\"macro\">assert!</span>(iter.next().is_none());</code></pre></div>\n<p>There’s no <code>windows_mut</code>, as that existing would let safe code violate the\n“only one <code>&amp;mut</code> at a time to the same thing” rule.  However, you can sometimes\nuse <a href=\"https://doc.rust-lang.org/1.85.0/core/cell/struct.Cell.html#method.as_slice_of_cells\" title=\"method core::cell::Cell::as_slice_of_cells\"><code>Cell::as_slice_of_cells</code></a> in\nconjunction with <code>windows</code> to accomplish something similar:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::cell::Cell;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>array = [<span class=\"string\">'R'</span>, <span class=\"string\">'u'</span>, <span class=\"string\">'s'</span>, <span class=\"string\">'t'</span>, <span class=\"string\">' '</span>, <span class=\"string\">'2'</span>, <span class=\"string\">'0'</span>, <span class=\"string\">'1'</span>, <span class=\"string\">'5'</span>];\n<span class=\"kw\">let </span>slice = <span class=\"kw-2\">&amp;mut </span>array[..];\n<span class=\"kw\">let </span>slice_of_cells: <span class=\"kw-2\">&amp;</span>[Cell&lt;char&gt;] = Cell::from_mut(slice).as_slice_of_cells();\n<span class=\"kw\">for </span>w <span class=\"kw\">in </span>slice_of_cells.windows(<span class=\"number\">3</span>) {\n    Cell::swap(<span class=\"kw-2\">&amp;</span>w[<span class=\"number\">0</span>], <span class=\"kw-2\">&amp;</span>w[<span class=\"number\">2</span>]);\n}\n<span class=\"macro\">assert_eq!</span>(array, [<span class=\"string\">'s'</span>, <span class=\"string\">'t'</span>, <span class=\"string\">' '</span>, <span class=\"string\">'2'</span>, <span class=\"string\">'0'</span>, <span class=\"string\">'1'</span>, <span class=\"string\">'5'</span>, <span class=\"string\">'u'</span>, <span class=\"string\">'R'</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.chunks\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#1153\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.chunks\" class=\"fn\">chunks</a>(&amp;self, chunk_size: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/iter/struct.Chunks.html\" title=\"struct core::slice::iter::Chunks\">Chunks</a>&lt;'_, T&gt;</h4></section></summary><div class=\"docblock\"><p>Returns an iterator over <code>chunk_size</code> elements of the slice at a time, starting at the\nbeginning of the slice.</p>\n<p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not divide the length of the\nslice, then the last chunk will not have length <code>chunk_size</code>.</p>\n<p>See <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.chunks_exact\" title=\"method slice::chunks_exact\"><code>chunks_exact</code></a> for a variant of this iterator that returns chunks of always exactly\n<code>chunk_size</code> elements, and <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.rchunks\" title=\"method slice::rchunks\"><code>rchunks</code></a> for the same iterator but starting at the end of the\nslice.</p>\n<h5 id=\"panics-2\"><a class=\"doc-anchor\" href=\"#panics-2\">§</a>Panics</h5>\n<p>Panics if <code>chunk_size</code> is zero.</p>\n<h5 id=\"examples-30\"><a class=\"doc-anchor\" href=\"#examples-30\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>slice = [<span class=\"string\">'l'</span>, <span class=\"string\">'o'</span>, <span class=\"string\">'r'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'m'</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = slice.chunks(<span class=\"number\">2</span>);\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'l'</span>, <span class=\"string\">'o'</span>]);\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'r'</span>, <span class=\"string\">'e'</span>]);\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'m'</span>]);\n<span class=\"macro\">assert!</span>(iter.next().is_none());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.chunks_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#1192\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.chunks_mut\" class=\"fn\">chunks_mut</a>(&amp;mut self, chunk_size: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/iter/struct.ChunksMut.html\" title=\"struct core::slice::iter::ChunksMut\">ChunksMut</a>&lt;'_, T&gt;</h4></section></summary><div class=\"docblock\"><p>Returns an iterator over <code>chunk_size</code> elements of the slice at a time, starting at the\nbeginning of the slice.</p>\n<p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does not divide the\nlength of the slice, then the last chunk will not have length <code>chunk_size</code>.</p>\n<p>See <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.chunks_exact_mut\" title=\"method slice::chunks_exact_mut\"><code>chunks_exact_mut</code></a> for a variant of this iterator that returns chunks of always\nexactly <code>chunk_size</code> elements, and <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.rchunks_mut\" title=\"method slice::rchunks_mut\"><code>rchunks_mut</code></a> for the same iterator but starting at\nthe end of the slice.</p>\n<h5 id=\"panics-3\"><a class=\"doc-anchor\" href=\"#panics-3\">§</a>Panics</h5>\n<p>Panics if <code>chunk_size</code> is zero.</p>\n<h5 id=\"examples-31\"><a class=\"doc-anchor\" href=\"#examples-31\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>count = <span class=\"number\">1</span>;\n\n<span class=\"kw\">for </span>chunk <span class=\"kw\">in </span>v.chunks_mut(<span class=\"number\">2</span>) {\n    <span class=\"kw\">for </span>elem <span class=\"kw\">in </span>chunk.iter_mut() {\n        <span class=\"kw-2\">*</span>elem += count;\n    }\n    count += <span class=\"number\">1</span>;\n}\n<span class=\"macro\">assert_eq!</span>(v, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.chunks_exact\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.31.0\">1.31.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#1230\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.chunks_exact\" class=\"fn\">chunks_exact</a>(&amp;self, chunk_size: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/iter/struct.ChunksExact.html\" title=\"struct core::slice::iter::ChunksExact\">ChunksExact</a>&lt;'_, T&gt;</h4></section></summary><div class=\"docblock\"><p>Returns an iterator over <code>chunk_size</code> elements of the slice at a time, starting at the\nbeginning of the slice.</p>\n<p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not divide the length of the\nslice, then the last up to <code>chunk_size-1</code> elements will be omitted and can be retrieved\nfrom the <code>remainder</code> function of the iterator.</p>\n<p>Due to each chunk having exactly <code>chunk_size</code> elements, the compiler can often optimize the\nresulting code better than in the case of <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.chunks\" title=\"method slice::chunks\"><code>chunks</code></a>.</p>\n<p>See <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.chunks\" title=\"method slice::chunks\"><code>chunks</code></a> for a variant of this iterator that also returns the remainder as a smaller\nchunk, and <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.rchunks_exact\" title=\"method slice::rchunks_exact\"><code>rchunks_exact</code></a> for the same iterator but starting at the end of the slice.</p>\n<h5 id=\"panics-4\"><a class=\"doc-anchor\" href=\"#panics-4\">§</a>Panics</h5>\n<p>Panics if <code>chunk_size</code> is zero.</p>\n<h5 id=\"examples-32\"><a class=\"doc-anchor\" href=\"#examples-32\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>slice = [<span class=\"string\">'l'</span>, <span class=\"string\">'o'</span>, <span class=\"string\">'r'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'m'</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = slice.chunks_exact(<span class=\"number\">2</span>);\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'l'</span>, <span class=\"string\">'o'</span>]);\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'r'</span>, <span class=\"string\">'e'</span>]);\n<span class=\"macro\">assert!</span>(iter.next().is_none());\n<span class=\"macro\">assert_eq!</span>(iter.remainder(), <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'m'</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.chunks_exact_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.31.0\">1.31.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#1273\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.chunks_exact_mut\" class=\"fn\">chunks_exact_mut</a>(&amp;mut self, chunk_size: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/iter/struct.ChunksExactMut.html\" title=\"struct core::slice::iter::ChunksExactMut\">ChunksExactMut</a>&lt;'_, T&gt;</h4></section></summary><div class=\"docblock\"><p>Returns an iterator over <code>chunk_size</code> elements of the slice at a time, starting at the\nbeginning of the slice.</p>\n<p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does not divide the\nlength of the slice, then the last up to <code>chunk_size-1</code> elements will be omitted and can be\nretrieved from the <code>into_remainder</code> function of the iterator.</p>\n<p>Due to each chunk having exactly <code>chunk_size</code> elements, the compiler can often optimize the\nresulting code better than in the case of <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.chunks_mut\" title=\"method slice::chunks_mut\"><code>chunks_mut</code></a>.</p>\n<p>See <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.chunks_mut\" title=\"method slice::chunks_mut\"><code>chunks_mut</code></a> for a variant of this iterator that also returns the remainder as a\nsmaller chunk, and <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.rchunks_exact_mut\" title=\"method slice::rchunks_exact_mut\"><code>rchunks_exact_mut</code></a> for the same iterator but starting at the end of\nthe slice.</p>\n<h5 id=\"panics-5\"><a class=\"doc-anchor\" href=\"#panics-5\">§</a>Panics</h5>\n<p>Panics if <code>chunk_size</code> is zero.</p>\n<h5 id=\"examples-33\"><a class=\"doc-anchor\" href=\"#examples-33\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>count = <span class=\"number\">1</span>;\n\n<span class=\"kw\">for </span>chunk <span class=\"kw\">in </span>v.chunks_exact_mut(<span class=\"number\">2</span>) {\n    <span class=\"kw\">for </span>elem <span class=\"kw\">in </span>chunk.iter_mut() {\n        <span class=\"kw-2\">*</span>elem += count;\n    }\n    count += <span class=\"number\">1</span>;\n}\n<span class=\"macro\">assert_eq!</span>(v, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_chunks_unchecked\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#1309\">Source</a><h4 class=\"code-header\">pub const unsafe fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.as_chunks_unchecked\" class=\"fn\">as_chunks_unchecked</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;(&amp;self) -&gt; &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.array.html\">[T; N]</a>]</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_as_chunks</code>)</span></div></span></summary><div class=\"docblock\"><p>Splits the slice into a slice of <code>N</code>-element arrays,\nassuming that there’s no remainder.</p>\n<h5 id=\"safety-3\"><a class=\"doc-anchor\" href=\"#safety-3\">§</a>Safety</h5>\n<p>This may only be called when</p>\n<ul>\n<li>The slice splits exactly into <code>N</code>-element chunks (aka <code>self.len() % N == 0</code>).</li>\n<li><code>N != 0</code>.</li>\n</ul>\n<h5 id=\"examples-34\"><a class=\"doc-anchor\" href=\"#examples-34\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(slice_as_chunks)]\n</span><span class=\"kw\">let </span>slice: <span class=\"kw-2\">&amp;</span>[char] = <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'l'</span>, <span class=\"string\">'o'</span>, <span class=\"string\">'r'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'m'</span>, <span class=\"string\">'!'</span>];\n<span class=\"kw\">let </span>chunks: <span class=\"kw-2\">&amp;</span>[[char; <span class=\"number\">1</span>]] =\n    <span class=\"comment\">// SAFETY: 1-element chunks never have remainder\n    </span><span class=\"kw\">unsafe </span>{ slice.as_chunks_unchecked() };\n<span class=\"macro\">assert_eq!</span>(chunks, <span class=\"kw-2\">&amp;</span>[[<span class=\"string\">'l'</span>], [<span class=\"string\">'o'</span>], [<span class=\"string\">'r'</span>], [<span class=\"string\">'e'</span>], [<span class=\"string\">'m'</span>], [<span class=\"string\">'!'</span>]]);\n<span class=\"kw\">let </span>chunks: <span class=\"kw-2\">&amp;</span>[[char; <span class=\"number\">3</span>]] =\n    <span class=\"comment\">// SAFETY: The slice length (6) is a multiple of 3\n    </span><span class=\"kw\">unsafe </span>{ slice.as_chunks_unchecked() };\n<span class=\"macro\">assert_eq!</span>(chunks, <span class=\"kw-2\">&amp;</span>[[<span class=\"string\">'l'</span>, <span class=\"string\">'o'</span>, <span class=\"string\">'r'</span>], [<span class=\"string\">'e'</span>, <span class=\"string\">'m'</span>, <span class=\"string\">'!'</span>]]);\n\n<span class=\"comment\">// These would be unsound:\n// let chunks: &amp;[[_; 5]] = slice.as_chunks_unchecked() // The slice length is not a multiple of 5\n// let chunks: &amp;[[_; 0]] = slice.as_chunks_unchecked() // Zero-length chunks are never allowed</span></code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_chunks\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#1356\">Source</a><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.as_chunks\" class=\"fn\">as_chunks</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;(&amp;self) -&gt; (&amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.array.html\">[T; N]</a>], &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_as_chunks</code>)</span></div></span></summary><div class=\"docblock\"><p>Splits the slice into a slice of <code>N</code>-element arrays,\nstarting at the beginning of the slice,\nand a remainder slice with length strictly less than <code>N</code>.</p>\n<h5 id=\"panics-6\"><a class=\"doc-anchor\" href=\"#panics-6\">§</a>Panics</h5>\n<p>Panics if <code>N</code> is zero. This check will most probably get changed to a compile time\nerror before this method gets stabilized.</p>\n<h5 id=\"examples-35\"><a class=\"doc-anchor\" href=\"#examples-35\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(slice_as_chunks)]\n</span><span class=\"kw\">let </span>slice = [<span class=\"string\">'l'</span>, <span class=\"string\">'o'</span>, <span class=\"string\">'r'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'m'</span>];\n<span class=\"kw\">let </span>(chunks, remainder) = slice.as_chunks();\n<span class=\"macro\">assert_eq!</span>(chunks, <span class=\"kw-2\">&amp;</span>[[<span class=\"string\">'l'</span>, <span class=\"string\">'o'</span>], [<span class=\"string\">'r'</span>, <span class=\"string\">'e'</span>]]);\n<span class=\"macro\">assert_eq!</span>(remainder, <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'m'</span>]);</code></pre></div>\n<p>If you expect the slice to be an exact multiple, you can combine\n<code>let</code>-<code>else</code> with an empty slice pattern:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(slice_as_chunks)]\n</span><span class=\"kw\">let </span>slice = [<span class=\"string\">'R'</span>, <span class=\"string\">'u'</span>, <span class=\"string\">'s'</span>, <span class=\"string\">'t'</span>];\n<span class=\"kw\">let </span>(chunks, []) = slice.as_chunks::&lt;<span class=\"number\">2</span>&gt;() <span class=\"kw\">else </span>{\n    <span class=\"macro\">panic!</span>(<span class=\"string\">\"slice didn't have even length\"</span>)\n};\n<span class=\"macro\">assert_eq!</span>(chunks, <span class=\"kw-2\">&amp;</span>[[<span class=\"string\">'R'</span>, <span class=\"string\">'u'</span>], [<span class=\"string\">'s'</span>, <span class=\"string\">'t'</span>]]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_rchunks\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#1391\">Source</a><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.as_rchunks\" class=\"fn\">as_rchunks</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;(&amp;self) -&gt; (&amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>, &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.array.html\">[T; N]</a>])</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_as_chunks</code>)</span></div></span></summary><div class=\"docblock\"><p>Splits the slice into a slice of <code>N</code>-element arrays,\nstarting at the end of the slice,\nand a remainder slice with length strictly less than <code>N</code>.</p>\n<h5 id=\"panics-7\"><a class=\"doc-anchor\" href=\"#panics-7\">§</a>Panics</h5>\n<p>Panics if <code>N</code> is zero. This check will most probably get changed to a compile time\nerror before this method gets stabilized.</p>\n<h5 id=\"examples-36\"><a class=\"doc-anchor\" href=\"#examples-36\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(slice_as_chunks)]\n</span><span class=\"kw\">let </span>slice = [<span class=\"string\">'l'</span>, <span class=\"string\">'o'</span>, <span class=\"string\">'r'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'m'</span>];\n<span class=\"kw\">let </span>(remainder, chunks) = slice.as_rchunks();\n<span class=\"macro\">assert_eq!</span>(remainder, <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'l'</span>]);\n<span class=\"macro\">assert_eq!</span>(chunks, <span class=\"kw-2\">&amp;</span>[[<span class=\"string\">'o'</span>, <span class=\"string\">'r'</span>], [<span class=\"string\">'e'</span>, <span class=\"string\">'m'</span>]]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.array_chunks\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#1431\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.array_chunks\" class=\"fn\">array_chunks</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;(&amp;self) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/iter/struct.ArrayChunks.html\" title=\"struct core::slice::iter::ArrayChunks\">ArrayChunks</a>&lt;'_, T, N&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>array_chunks</code>)</span></div></span></summary><div class=\"docblock\"><p>Returns an iterator over <code>N</code> elements of the slice at a time, starting at the\nbeginning of the slice.</p>\n<p>The chunks are array references and do not overlap. If <code>N</code> does not divide the\nlength of the slice, then the last up to <code>N-1</code> elements will be omitted and can be\nretrieved from the <code>remainder</code> function of the iterator.</p>\n<p>This method is the const generic equivalent of <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.chunks_exact\" title=\"method slice::chunks_exact\"><code>chunks_exact</code></a>.</p>\n<h5 id=\"panics-8\"><a class=\"doc-anchor\" href=\"#panics-8\">§</a>Panics</h5>\n<p>Panics if <code>N</code> is zero. This check will most probably get changed to a compile time\nerror before this method gets stabilized.</p>\n<h5 id=\"examples-37\"><a class=\"doc-anchor\" href=\"#examples-37\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(array_chunks)]\n</span><span class=\"kw\">let </span>slice = [<span class=\"string\">'l'</span>, <span class=\"string\">'o'</span>, <span class=\"string\">'r'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'m'</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = slice.array_chunks();\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'l'</span>, <span class=\"string\">'o'</span>]);\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'r'</span>, <span class=\"string\">'e'</span>]);\n<span class=\"macro\">assert!</span>(iter.next().is_none());\n<span class=\"macro\">assert_eq!</span>(iter.remainder(), <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'m'</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_chunks_unchecked_mut\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#1469\">Source</a><h4 class=\"code-header\">pub const unsafe fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.as_chunks_unchecked_mut\" class=\"fn\">as_chunks_unchecked_mut</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;(\n    &amp;mut self,\n) -&gt; &amp;mut [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.array.html\">[T; N]</a>]</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_as_chunks</code>)</span></div></span></summary><div class=\"docblock\"><p>Splits the slice into a slice of <code>N</code>-element arrays,\nassuming that there’s no remainder.</p>\n<h5 id=\"safety-4\"><a class=\"doc-anchor\" href=\"#safety-4\">§</a>Safety</h5>\n<p>This may only be called when</p>\n<ul>\n<li>The slice splits exactly into <code>N</code>-element chunks (aka <code>self.len() % N == 0</code>).</li>\n<li><code>N != 0</code>.</li>\n</ul>\n<h5 id=\"examples-38\"><a class=\"doc-anchor\" href=\"#examples-38\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(slice_as_chunks)]\n</span><span class=\"kw\">let </span>slice: <span class=\"kw-2\">&amp;mut </span>[char] = <span class=\"kw-2\">&amp;mut </span>[<span class=\"string\">'l'</span>, <span class=\"string\">'o'</span>, <span class=\"string\">'r'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'m'</span>, <span class=\"string\">'!'</span>];\n<span class=\"kw\">let </span>chunks: <span class=\"kw-2\">&amp;mut </span>[[char; <span class=\"number\">1</span>]] =\n    <span class=\"comment\">// SAFETY: 1-element chunks never have remainder\n    </span><span class=\"kw\">unsafe </span>{ slice.as_chunks_unchecked_mut() };\nchunks[<span class=\"number\">0</span>] = [<span class=\"string\">'L'</span>];\n<span class=\"macro\">assert_eq!</span>(chunks, <span class=\"kw-2\">&amp;</span>[[<span class=\"string\">'L'</span>], [<span class=\"string\">'o'</span>], [<span class=\"string\">'r'</span>], [<span class=\"string\">'e'</span>], [<span class=\"string\">'m'</span>], [<span class=\"string\">'!'</span>]]);\n<span class=\"kw\">let </span>chunks: <span class=\"kw-2\">&amp;mut </span>[[char; <span class=\"number\">3</span>]] =\n    <span class=\"comment\">// SAFETY: The slice length (6) is a multiple of 3\n    </span><span class=\"kw\">unsafe </span>{ slice.as_chunks_unchecked_mut() };\nchunks[<span class=\"number\">1</span>] = [<span class=\"string\">'a'</span>, <span class=\"string\">'x'</span>, <span class=\"string\">'?'</span>];\n<span class=\"macro\">assert_eq!</span>(slice, <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'L'</span>, <span class=\"string\">'o'</span>, <span class=\"string\">'r'</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'x'</span>, <span class=\"string\">'?'</span>]);\n\n<span class=\"comment\">// These would be unsound:\n// let chunks: &amp;[[_; 5]] = slice.as_chunks_unchecked_mut() // The slice length is not a multiple of 5\n// let chunks: &amp;[[_; 0]] = slice.as_chunks_unchecked_mut() // Zero-length chunks are never allowed</span></code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_chunks_mut\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#1511\">Source</a><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.as_chunks_mut\" class=\"fn\">as_chunks_mut</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;(\n    &amp;mut self,\n) -&gt; (&amp;mut [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.array.html\">[T; N]</a>], &amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_as_chunks</code>)</span></div></span></summary><div class=\"docblock\"><p>Splits the slice into a slice of <code>N</code>-element arrays,\nstarting at the beginning of the slice,\nand a remainder slice with length strictly less than <code>N</code>.</p>\n<h5 id=\"panics-9\"><a class=\"doc-anchor\" href=\"#panics-9\">§</a>Panics</h5>\n<p>Panics if <code>N</code> is zero. This check will most probably get changed to a compile time\nerror before this method gets stabilized.</p>\n<h5 id=\"examples-39\"><a class=\"doc-anchor\" href=\"#examples-39\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(slice_as_chunks)]\n</span><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>count = <span class=\"number\">1</span>;\n\n<span class=\"kw\">let </span>(chunks, remainder) = v.as_chunks_mut();\nremainder[<span class=\"number\">0</span>] = <span class=\"number\">9</span>;\n<span class=\"kw\">for </span>chunk <span class=\"kw\">in </span>chunks {\n    <span class=\"kw-2\">*</span>chunk = [count; <span class=\"number\">2</span>];\n    count += <span class=\"number\">1</span>;\n}\n<span class=\"macro\">assert_eq!</span>(v, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_rchunks_mut\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#1552\">Source</a><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.as_rchunks_mut\" class=\"fn\">as_rchunks_mut</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;(\n    &amp;mut self,\n) -&gt; (&amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>, &amp;mut [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.array.html\">[T; N]</a>])</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_as_chunks</code>)</span></div></span></summary><div class=\"docblock\"><p>Splits the slice into a slice of <code>N</code>-element arrays,\nstarting at the end of the slice,\nand a remainder slice with length strictly less than <code>N</code>.</p>\n<h5 id=\"panics-10\"><a class=\"doc-anchor\" href=\"#panics-10\">§</a>Panics</h5>\n<p>Panics if <code>N</code> is zero. This check will most probably get changed to a compile time\nerror before this method gets stabilized.</p>\n<h5 id=\"examples-40\"><a class=\"doc-anchor\" href=\"#examples-40\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(slice_as_chunks)]\n</span><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>count = <span class=\"number\">1</span>;\n\n<span class=\"kw\">let </span>(remainder, chunks) = v.as_rchunks_mut();\nremainder[<span class=\"number\">0</span>] = <span class=\"number\">9</span>;\n<span class=\"kw\">for </span>chunk <span class=\"kw\">in </span>chunks {\n    <span class=\"kw-2\">*</span>chunk = [count; <span class=\"number\">2</span>];\n    count += <span class=\"number\">1</span>;\n}\n<span class=\"macro\">assert_eq!</span>(v, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">9</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.array_chunks_mut\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#1594\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.array_chunks_mut\" class=\"fn\">array_chunks_mut</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;(&amp;mut self) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/iter/struct.ArrayChunksMut.html\" title=\"struct core::slice::iter::ArrayChunksMut\">ArrayChunksMut</a>&lt;'_, T, N&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>array_chunks</code>)</span></div></span></summary><div class=\"docblock\"><p>Returns an iterator over <code>N</code> elements of the slice at a time, starting at the\nbeginning of the slice.</p>\n<p>The chunks are mutable array references and do not overlap. If <code>N</code> does not divide\nthe length of the slice, then the last up to <code>N-1</code> elements will be omitted and\ncan be retrieved from the <code>into_remainder</code> function of the iterator.</p>\n<p>This method is the const generic equivalent of <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.chunks_exact_mut\" title=\"method slice::chunks_exact_mut\"><code>chunks_exact_mut</code></a>.</p>\n<h5 id=\"panics-11\"><a class=\"doc-anchor\" href=\"#panics-11\">§</a>Panics</h5>\n<p>Panics if <code>N</code> is zero. This check will most probably get changed to a compile time\nerror before this method gets stabilized.</p>\n<h5 id=\"examples-41\"><a class=\"doc-anchor\" href=\"#examples-41\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(array_chunks)]\n</span><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>count = <span class=\"number\">1</span>;\n\n<span class=\"kw\">for </span>chunk <span class=\"kw\">in </span>v.array_chunks_mut() {\n    <span class=\"kw-2\">*</span>chunk = [count; <span class=\"number\">2</span>];\n    count += <span class=\"number\">1</span>;\n}\n<span class=\"macro\">assert_eq!</span>(v, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.array_windows\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#1627\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.array_windows\" class=\"fn\">array_windows</a>&lt;const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;(&amp;self) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/iter/struct.ArrayWindows.html\" title=\"struct core::slice::iter::ArrayWindows\">ArrayWindows</a>&lt;'_, T, N&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>array_windows</code>)</span></div></span></summary><div class=\"docblock\"><p>Returns an iterator over overlapping windows of <code>N</code> elements of a slice,\nstarting at the beginning of the slice.</p>\n<p>This is the const generic equivalent of <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.windows\" title=\"method slice::windows\"><code>windows</code></a>.</p>\n<p>If <code>N</code> is greater than the size of the slice, it will return no windows.</p>\n<h5 id=\"panics-12\"><a class=\"doc-anchor\" href=\"#panics-12\">§</a>Panics</h5>\n<p>Panics if <code>N</code> is zero. This check will most probably get changed to a compile time\nerror before this method gets stabilized.</p>\n<h5 id=\"examples-42\"><a class=\"doc-anchor\" href=\"#examples-42\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(array_windows)]\n</span><span class=\"kw\">let </span>slice = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = slice.array_windows();\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>]);\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>]);\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"number\">2</span>, <span class=\"number\">3</span>]);\n<span class=\"macro\">assert!</span>(iter.next().is_none());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.rchunks\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.31.0\">1.31.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#1662\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.rchunks\" class=\"fn\">rchunks</a>(&amp;self, chunk_size: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/iter/struct.RChunks.html\" title=\"struct core::slice::iter::RChunks\">RChunks</a>&lt;'_, T&gt;</h4></section></summary><div class=\"docblock\"><p>Returns an iterator over <code>chunk_size</code> elements of the slice at a time, starting at the end\nof the slice.</p>\n<p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not divide the length of the\nslice, then the last chunk will not have length <code>chunk_size</code>.</p>\n<p>See <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.rchunks_exact\" title=\"method slice::rchunks_exact\"><code>rchunks_exact</code></a> for a variant of this iterator that returns chunks of always exactly\n<code>chunk_size</code> elements, and <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.chunks\" title=\"method slice::chunks\"><code>chunks</code></a> for the same iterator but starting at the beginning\nof the slice.</p>\n<h5 id=\"panics-13\"><a class=\"doc-anchor\" href=\"#panics-13\">§</a>Panics</h5>\n<p>Panics if <code>chunk_size</code> is zero.</p>\n<h5 id=\"examples-43\"><a class=\"doc-anchor\" href=\"#examples-43\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>slice = [<span class=\"string\">'l'</span>, <span class=\"string\">'o'</span>, <span class=\"string\">'r'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'m'</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = slice.rchunks(<span class=\"number\">2</span>);\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'e'</span>, <span class=\"string\">'m'</span>]);\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'o'</span>, <span class=\"string\">'r'</span>]);\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'l'</span>]);\n<span class=\"macro\">assert!</span>(iter.next().is_none());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.rchunks_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.31.0\">1.31.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#1701\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.rchunks_mut\" class=\"fn\">rchunks_mut</a>(&amp;mut self, chunk_size: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/iter/struct.RChunksMut.html\" title=\"struct core::slice::iter::RChunksMut\">RChunksMut</a>&lt;'_, T&gt;</h4></section></summary><div class=\"docblock\"><p>Returns an iterator over <code>chunk_size</code> elements of the slice at a time, starting at the end\nof the slice.</p>\n<p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does not divide the\nlength of the slice, then the last chunk will not have length <code>chunk_size</code>.</p>\n<p>See <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.rchunks_exact_mut\" title=\"method slice::rchunks_exact_mut\"><code>rchunks_exact_mut</code></a> for a variant of this iterator that returns chunks of always\nexactly <code>chunk_size</code> elements, and <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.chunks_mut\" title=\"method slice::chunks_mut\"><code>chunks_mut</code></a> for the same iterator but starting at the\nbeginning of the slice.</p>\n<h5 id=\"panics-14\"><a class=\"doc-anchor\" href=\"#panics-14\">§</a>Panics</h5>\n<p>Panics if <code>chunk_size</code> is zero.</p>\n<h5 id=\"examples-44\"><a class=\"doc-anchor\" href=\"#examples-44\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>count = <span class=\"number\">1</span>;\n\n<span class=\"kw\">for </span>chunk <span class=\"kw\">in </span>v.rchunks_mut(<span class=\"number\">2</span>) {\n    <span class=\"kw\">for </span>elem <span class=\"kw\">in </span>chunk.iter_mut() {\n        <span class=\"kw-2\">*</span>elem += count;\n    }\n    count += <span class=\"number\">1</span>;\n}\n<span class=\"macro\">assert_eq!</span>(v, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.rchunks_exact\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.31.0\">1.31.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#1741\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.rchunks_exact\" class=\"fn\">rchunks_exact</a>(&amp;self, chunk_size: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/iter/struct.RChunksExact.html\" title=\"struct core::slice::iter::RChunksExact\">RChunksExact</a>&lt;'_, T&gt;</h4></section></summary><div class=\"docblock\"><p>Returns an iterator over <code>chunk_size</code> elements of the slice at a time, starting at the\nend of the slice.</p>\n<p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not divide the length of the\nslice, then the last up to <code>chunk_size-1</code> elements will be omitted and can be retrieved\nfrom the <code>remainder</code> function of the iterator.</p>\n<p>Due to each chunk having exactly <code>chunk_size</code> elements, the compiler can often optimize the\nresulting code better than in the case of <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.rchunks\" title=\"method slice::rchunks\"><code>rchunks</code></a>.</p>\n<p>See <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.rchunks\" title=\"method slice::rchunks\"><code>rchunks</code></a> for a variant of this iterator that also returns the remainder as a smaller\nchunk, and <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.chunks_exact\" title=\"method slice::chunks_exact\"><code>chunks_exact</code></a> for the same iterator but starting at the beginning of the\nslice.</p>\n<h5 id=\"panics-15\"><a class=\"doc-anchor\" href=\"#panics-15\">§</a>Panics</h5>\n<p>Panics if <code>chunk_size</code> is zero.</p>\n<h5 id=\"examples-45\"><a class=\"doc-anchor\" href=\"#examples-45\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>slice = [<span class=\"string\">'l'</span>, <span class=\"string\">'o'</span>, <span class=\"string\">'r'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'m'</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = slice.rchunks_exact(<span class=\"number\">2</span>);\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'e'</span>, <span class=\"string\">'m'</span>]);\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'o'</span>, <span class=\"string\">'r'</span>]);\n<span class=\"macro\">assert!</span>(iter.next().is_none());\n<span class=\"macro\">assert_eq!</span>(iter.remainder(), <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'l'</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.rchunks_exact_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.31.0\">1.31.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#1785\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.rchunks_exact_mut\" class=\"fn\">rchunks_exact_mut</a>(&amp;mut self, chunk_size: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/iter/struct.RChunksExactMut.html\" title=\"struct core::slice::iter::RChunksExactMut\">RChunksExactMut</a>&lt;'_, T&gt;</h4></section></summary><div class=\"docblock\"><p>Returns an iterator over <code>chunk_size</code> elements of the slice at a time, starting at the end\nof the slice.</p>\n<p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does not divide the\nlength of the slice, then the last up to <code>chunk_size-1</code> elements will be omitted and can be\nretrieved from the <code>into_remainder</code> function of the iterator.</p>\n<p>Due to each chunk having exactly <code>chunk_size</code> elements, the compiler can often optimize the\nresulting code better than in the case of <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.chunks_mut\" title=\"method slice::chunks_mut\"><code>chunks_mut</code></a>.</p>\n<p>See <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.rchunks_mut\" title=\"method slice::rchunks_mut\"><code>rchunks_mut</code></a> for a variant of this iterator that also returns the remainder as a\nsmaller chunk, and <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.chunks_exact_mut\" title=\"method slice::chunks_exact_mut\"><code>chunks_exact_mut</code></a> for the same iterator but starting at the beginning\nof the slice.</p>\n<h5 id=\"panics-16\"><a class=\"doc-anchor\" href=\"#panics-16\">§</a>Panics</h5>\n<p>Panics if <code>chunk_size</code> is zero.</p>\n<h5 id=\"examples-46\"><a class=\"doc-anchor\" href=\"#examples-46\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>count = <span class=\"number\">1</span>;\n\n<span class=\"kw\">for </span>chunk <span class=\"kw\">in </span>v.rchunks_exact_mut(<span class=\"number\">2</span>) {\n    <span class=\"kw\">for </span>elem <span class=\"kw\">in </span>chunk.iter_mut() {\n        <span class=\"kw-2\">*</span>elem += count;\n    }\n    count += <span class=\"number\">1</span>;\n}\n<span class=\"macro\">assert_eq!</span>(v, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.chunk_by\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.77.0\">1.77.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#1824-1826\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.chunk_by\" class=\"fn\">chunk_by</a>&lt;F&gt;(&amp;self, pred: F) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/iter/struct.ChunkBy.html\" title=\"struct core::slice::iter::ChunkBy\">ChunkBy</a>&lt;'_, T, F&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns an iterator over the slice producing non-overlapping runs\nof elements using the predicate to separate them.</p>\n<p>The predicate is called for every pair of consecutive elements,\nmeaning that it is called on <code>slice[0]</code> and <code>slice[1]</code>,\nfollowed by <code>slice[1]</code> and <code>slice[2]</code>, and so on.</p>\n<h5 id=\"examples-47\"><a class=\"doc-anchor\" href=\"#examples-47\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>slice = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = slice.chunk_by(|a, b| a == b);\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>][..]));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">3</span>, <span class=\"number\">3</span>][..]));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>][..]));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre></div>\n<p>This method can be used to extract the sorted subslices:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>slice = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = slice.chunk_by(|a, b| a &lt;= b);\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>][..]));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">2</span>, <span class=\"number\">3</span>][..]));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>][..]));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.chunk_by_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.77.0\">1.77.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#1865-1867\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.chunk_by_mut\" class=\"fn\">chunk_by_mut</a>&lt;F&gt;(&amp;mut self, pred: F) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/iter/struct.ChunkByMut.html\" title=\"struct core::slice::iter::ChunkByMut\">ChunkByMut</a>&lt;'_, T, F&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns an iterator over the slice producing non-overlapping mutable\nruns of elements using the predicate to separate them.</p>\n<p>The predicate is called for every pair of consecutive elements,\nmeaning that it is called on <code>slice[0]</code> and <code>slice[1]</code>,\nfollowed by <code>slice[1]</code> and <code>slice[2]</code>, and so on.</p>\n<h5 id=\"examples-48\"><a class=\"doc-anchor\" href=\"#examples-48\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>slice = <span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = slice.chunk_by_mut(|a, b| a == b);\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>][..]));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">3</span>, <span class=\"number\">3</span>][..]));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>][..]));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre></div>\n<p>This method can be used to extract the sorted subslices:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>slice = <span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = slice.chunk_by_mut(|a, b| a &lt;= b);\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>][..]));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">2</span>, <span class=\"number\">3</span>][..]));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>][..]));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.split_at\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const since 1.71.0\">1.0.0 (const: 1.71.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#1911\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.split_at\" class=\"fn\">split_at</a>(&amp;self, mid: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>) -&gt; (&amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>, &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)</h4></section></summary><div class=\"docblock\"><p>Divides one slice into two at an index.</p>\n<p>The first will contain all indices from <code>[0, mid)</code> (excluding\nthe index <code>mid</code> itself) and the second will contain all\nindices from <code>[mid, len)</code> (excluding the index <code>len</code> itself).</p>\n<h5 id=\"panics-17\"><a class=\"doc-anchor\" href=\"#panics-17\">§</a>Panics</h5>\n<p>Panics if <code>mid &gt; len</code>.  For a non-panicking alternative see\n<a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.split_at_checked\" title=\"method slice::split_at_checked\"><code>split_at_checked</code></a>.</p>\n<h5 id=\"examples-49\"><a class=\"doc-anchor\" href=\"#examples-49\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>];\n\n{\n   <span class=\"kw\">let </span>(left, right) = v.split_at(<span class=\"number\">0</span>);\n   <span class=\"macro\">assert_eq!</span>(left, []);\n   <span class=\"macro\">assert_eq!</span>(right, [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>]);\n}\n\n{\n    <span class=\"kw\">let </span>(left, right) = v.split_at(<span class=\"number\">2</span>);\n    <span class=\"macro\">assert_eq!</span>(left, [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>]);\n    <span class=\"macro\">assert_eq!</span>(right, [<span class=\"string\">'c'</span>]);\n}\n\n{\n    <span class=\"kw\">let </span>(left, right) = v.split_at(<span class=\"number\">3</span>);\n    <span class=\"macro\">assert_eq!</span>(left, [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>]);\n    <span class=\"macro\">assert_eq!</span>(right, []);\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.split_at_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const since 1.83.0\">1.0.0 (const: 1.83.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#1945\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.split_at_mut\" class=\"fn\">split_at_mut</a>(&amp;mut self, mid: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>) -&gt; (&amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>, &amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)</h4></section></summary><div class=\"docblock\"><p>Divides one mutable slice into two at an index.</p>\n<p>The first will contain all indices from <code>[0, mid)</code> (excluding\nthe index <code>mid</code> itself) and the second will contain all\nindices from <code>[mid, len)</code> (excluding the index <code>len</code> itself).</p>\n<h5 id=\"panics-18\"><a class=\"doc-anchor\" href=\"#panics-18\">§</a>Panics</h5>\n<p>Panics if <code>mid &gt; len</code>.  For a non-panicking alternative see\n<a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.split_at_mut_checked\" title=\"method slice::split_at_mut_checked\"><code>split_at_mut_checked</code></a>.</p>\n<h5 id=\"examples-50\"><a class=\"doc-anchor\" href=\"#examples-50\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v = [<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>];\n<span class=\"kw\">let </span>(left, right) = v.split_at_mut(<span class=\"number\">2</span>);\n<span class=\"macro\">assert_eq!</span>(left, [<span class=\"number\">1</span>, <span class=\"number\">0</span>]);\n<span class=\"macro\">assert_eq!</span>(right, [<span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]);\nleft[<span class=\"number\">1</span>] = <span class=\"number\">2</span>;\nright[<span class=\"number\">1</span>] = <span class=\"number\">4</span>;\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.split_at_unchecked\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.79.0, const since 1.77.0\">1.79.0 (const: 1.77.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#1996\">Source</a></span><h4 class=\"code-header\">pub const unsafe fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.split_at_unchecked\" class=\"fn\">split_at_unchecked</a>(&amp;self, mid: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>) -&gt; (&amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>, &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)</h4></section></summary><div class=\"docblock\"><p>Divides one slice into two at an index, without doing bounds checking.</p>\n<p>The first will contain all indices from <code>[0, mid)</code> (excluding\nthe index <code>mid</code> itself) and the second will contain all\nindices from <code>[mid, len)</code> (excluding the index <code>len</code> itself).</p>\n<p>For a safe alternative see <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.split_at\" title=\"method slice::split_at\"><code>split_at</code></a>.</p>\n<h5 id=\"safety-5\"><a class=\"doc-anchor\" href=\"#safety-5\">§</a>Safety</h5>\n<p>Calling this method with an out-of-bounds index is <em><a href=\"https://doc.rust-lang.org/reference/behavior-considered-undefined.html\">undefined behavior</a></em>\neven if the resulting reference is not used. The caller has to ensure that\n<code>0 &lt;= mid &lt;= self.len()</code>.</p>\n<h5 id=\"examples-51\"><a class=\"doc-anchor\" href=\"#examples-51\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>];\n\n<span class=\"kw\">unsafe </span>{\n   <span class=\"kw\">let </span>(left, right) = v.split_at_unchecked(<span class=\"number\">0</span>);\n   <span class=\"macro\">assert_eq!</span>(left, []);\n   <span class=\"macro\">assert_eq!</span>(right, [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>]);\n}\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>(left, right) = v.split_at_unchecked(<span class=\"number\">2</span>);\n    <span class=\"macro\">assert_eq!</span>(left, [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>]);\n    <span class=\"macro\">assert_eq!</span>(right, [<span class=\"string\">'c'</span>]);\n}\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>(left, right) = v.split_at_unchecked(<span class=\"number\">3</span>);\n    <span class=\"macro\">assert_eq!</span>(left, [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>]);\n    <span class=\"macro\">assert_eq!</span>(right, []);\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.split_at_mut_unchecked\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.79.0, const since 1.83.0\">1.79.0 (const: 1.83.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#2049\">Source</a></span><h4 class=\"code-header\">pub const unsafe fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.split_at_mut_unchecked\" class=\"fn\">split_at_mut_unchecked</a>(\n    &amp;mut self,\n    mid: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>,\n) -&gt; (&amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>, &amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)</h4></section></summary><div class=\"docblock\"><p>Divides one mutable slice into two at an index, without doing bounds checking.</p>\n<p>The first will contain all indices from <code>[0, mid)</code> (excluding\nthe index <code>mid</code> itself) and the second will contain all\nindices from <code>[mid, len)</code> (excluding the index <code>len</code> itself).</p>\n<p>For a safe alternative see <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.split_at_mut\" title=\"method slice::split_at_mut\"><code>split_at_mut</code></a>.</p>\n<h5 id=\"safety-6\"><a class=\"doc-anchor\" href=\"#safety-6\">§</a>Safety</h5>\n<p>Calling this method with an out-of-bounds index is <em><a href=\"https://doc.rust-lang.org/reference/behavior-considered-undefined.html\">undefined behavior</a></em>\neven if the resulting reference is not used. The caller has to ensure that\n<code>0 &lt;= mid &lt;= self.len()</code>.</p>\n<h5 id=\"examples-52\"><a class=\"doc-anchor\" href=\"#examples-52\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v = [<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>];\n<span class=\"comment\">// scoped to restrict the lifetime of the borrows\n</span><span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>(left, right) = v.split_at_mut_unchecked(<span class=\"number\">2</span>);\n    <span class=\"macro\">assert_eq!</span>(left, [<span class=\"number\">1</span>, <span class=\"number\">0</span>]);\n    <span class=\"macro\">assert_eq!</span>(right, [<span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]);\n    left[<span class=\"number\">1</span>] = <span class=\"number\">2</span>;\n    right[<span class=\"number\">1</span>] = <span class=\"number\">4</span>;\n}\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.split_at_checked\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.80.0, const since 1.80.0\">1.80.0 (const: 1.80.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#2110\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.split_at_checked\" class=\"fn\">split_at_checked</a>(&amp;self, mid: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;(&amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>, &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)&gt;</h4></section></summary><div class=\"docblock\"><p>Divides one slice into two at an index, returning <code>None</code> if the slice is\ntoo short.</p>\n<p>If <code>mid ≤ len</code> returns a pair of slices where the first will contain all\nindices from <code>[0, mid)</code> (excluding the index <code>mid</code> itself) and the\nsecond will contain all indices from <code>[mid, len)</code> (excluding the index\n<code>len</code> itself).</p>\n<p>Otherwise, if <code>mid &gt; len</code>, returns <code>None</code>.</p>\n<h5 id=\"examples-53\"><a class=\"doc-anchor\" href=\"#examples-53\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = [<span class=\"number\">1</span>, -<span class=\"number\">2</span>, <span class=\"number\">3</span>, -<span class=\"number\">4</span>, <span class=\"number\">5</span>, -<span class=\"number\">6</span>];\n\n{\n   <span class=\"kw\">let </span>(left, right) = v.split_at_checked(<span class=\"number\">0</span>).unwrap();\n   <span class=\"macro\">assert_eq!</span>(left, []);\n   <span class=\"macro\">assert_eq!</span>(right, [<span class=\"number\">1</span>, -<span class=\"number\">2</span>, <span class=\"number\">3</span>, -<span class=\"number\">4</span>, <span class=\"number\">5</span>, -<span class=\"number\">6</span>]);\n}\n\n{\n    <span class=\"kw\">let </span>(left, right) = v.split_at_checked(<span class=\"number\">2</span>).unwrap();\n    <span class=\"macro\">assert_eq!</span>(left, [<span class=\"number\">1</span>, -<span class=\"number\">2</span>]);\n    <span class=\"macro\">assert_eq!</span>(right, [<span class=\"number\">3</span>, -<span class=\"number\">4</span>, <span class=\"number\">5</span>, -<span class=\"number\">6</span>]);\n}\n\n{\n    <span class=\"kw\">let </span>(left, right) = v.split_at_checked(<span class=\"number\">6</span>).unwrap();\n    <span class=\"macro\">assert_eq!</span>(left, [<span class=\"number\">1</span>, -<span class=\"number\">2</span>, <span class=\"number\">3</span>, -<span class=\"number\">4</span>, <span class=\"number\">5</span>, -<span class=\"number\">6</span>]);\n    <span class=\"macro\">assert_eq!</span>(right, []);\n}\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, v.split_at_checked(<span class=\"number\">7</span>));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.split_at_mut_checked\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.80.0, const since 1.83.0\">1.80.0 (const: 1.83.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#2149\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.split_at_mut_checked\" class=\"fn\">split_at_mut_checked</a>(\n    &amp;mut self,\n    mid: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;(&amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>, &amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)&gt;</h4></section></summary><div class=\"docblock\"><p>Divides one mutable slice into two at an index, returning <code>None</code> if the\nslice is too short.</p>\n<p>If <code>mid ≤ len</code> returns a pair of slices where the first will contain all\nindices from <code>[0, mid)</code> (excluding the index <code>mid</code> itself) and the\nsecond will contain all indices from <code>[mid, len)</code> (excluding the index\n<code>len</code> itself).</p>\n<p>Otherwise, if <code>mid &gt; len</code>, returns <code>None</code>.</p>\n<h5 id=\"examples-54\"><a class=\"doc-anchor\" href=\"#examples-54\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v = [<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>];\n\n<span class=\"kw\">if let </span><span class=\"prelude-val\">Some</span>((left, right)) = v.split_at_mut_checked(<span class=\"number\">2</span>) {\n    <span class=\"macro\">assert_eq!</span>(left, [<span class=\"number\">1</span>, <span class=\"number\">0</span>]);\n    <span class=\"macro\">assert_eq!</span>(right, [<span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]);\n    left[<span class=\"number\">1</span>] = <span class=\"number\">2</span>;\n    right[<span class=\"number\">1</span>] = <span class=\"number\">4</span>;\n}\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, v.split_at_mut_checked(<span class=\"number\">7</span>));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.split\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#2201-2203\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.split\" class=\"fn\">split</a>&lt;F&gt;(&amp;self, pred: F) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/iter/struct.Split.html\" title=\"struct core::slice::iter::Split\">Split</a>&lt;'_, T, F&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns an iterator over subslices separated by elements that match\n<code>pred</code>. The matched element is not contained in the subslices.</p>\n<h5 id=\"examples-55\"><a class=\"doc-anchor\" href=\"#examples-55\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>slice = [<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">33</span>, <span class=\"number\">20</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = slice.split(|num| num % <span class=\"number\">3 </span>== <span class=\"number\">0</span>);\n\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"number\">10</span>, <span class=\"number\">40</span>]);\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"number\">20</span>]);\n<span class=\"macro\">assert!</span>(iter.next().is_none());</code></pre></div>\n<p>If the first element is matched, an empty slice will be the first item\nreturned by the iterator. Similarly, if the last element in the slice\nis matched, an empty slice will be the last item returned by the\niterator:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>slice = [<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">33</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = slice.split(|num| num % <span class=\"number\">3 </span>== <span class=\"number\">0</span>);\n\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"number\">10</span>, <span class=\"number\">40</span>]);\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[]);\n<span class=\"macro\">assert!</span>(iter.next().is_none());</code></pre></div>\n<p>If two matched elements are directly adjacent, an empty slice will be\npresent between them:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>slice = [<span class=\"number\">10</span>, <span class=\"number\">6</span>, <span class=\"number\">33</span>, <span class=\"number\">20</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = slice.split(|num| num % <span class=\"number\">3 </span>== <span class=\"number\">0</span>);\n\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"number\">10</span>]);\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[]);\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"number\">20</span>]);\n<span class=\"macro\">assert!</span>(iter.next().is_none());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.split_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#2223-2225\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.split_mut\" class=\"fn\">split_mut</a>&lt;F&gt;(&amp;mut self, pred: F) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/iter/struct.SplitMut.html\" title=\"struct core::slice::iter::SplitMut\">SplitMut</a>&lt;'_, T, F&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns an iterator over mutable subslices separated by elements that\nmatch <code>pred</code>. The matched element is not contained in the subslices.</p>\n<h5 id=\"examples-56\"><a class=\"doc-anchor\" href=\"#examples-56\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v = [<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>, <span class=\"number\">20</span>, <span class=\"number\">60</span>, <span class=\"number\">50</span>];\n\n<span class=\"kw\">for </span>group <span class=\"kw\">in </span>v.split_mut(|num| <span class=\"kw-2\">*</span>num % <span class=\"number\">3 </span>== <span class=\"number\">0</span>) {\n    group[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;\n}\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"number\">1</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>, <span class=\"number\">1</span>, <span class=\"number\">60</span>, <span class=\"number\">1</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.split_inclusive\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.51.0\">1.51.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#2259-2261\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.split_inclusive\" class=\"fn\">split_inclusive</a>&lt;F&gt;(&amp;self, pred: F) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/iter/struct.SplitInclusive.html\" title=\"struct core::slice::iter::SplitInclusive\">SplitInclusive</a>&lt;'_, T, F&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns an iterator over subslices separated by elements that match\n<code>pred</code>. The matched element is contained in the end of the previous\nsubslice as a terminator.</p>\n<h5 id=\"examples-57\"><a class=\"doc-anchor\" href=\"#examples-57\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>slice = [<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">33</span>, <span class=\"number\">20</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = slice.split_inclusive(|num| num % <span class=\"number\">3 </span>== <span class=\"number\">0</span>);\n\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">33</span>]);\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"number\">20</span>]);\n<span class=\"macro\">assert!</span>(iter.next().is_none());</code></pre></div>\n<p>If the last element of the slice is matched,\nthat element will be considered the terminator of the preceding slice.\nThat slice will be the last item returned by the iterator.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>slice = [<span class=\"number\">3</span>, <span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">33</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = slice.split_inclusive(|num| num % <span class=\"number\">3 </span>== <span class=\"number\">0</span>);\n\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"number\">3</span>]);\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">33</span>]);\n<span class=\"macro\">assert!</span>(iter.next().is_none());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.split_inclusive_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.51.0\">1.51.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#2283-2285\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.split_inclusive_mut\" class=\"fn\">split_inclusive_mut</a>&lt;F&gt;(&amp;mut self, pred: F) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/iter/struct.SplitInclusiveMut.html\" title=\"struct core::slice::iter::SplitInclusiveMut\">SplitInclusiveMut</a>&lt;'_, T, F&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns an iterator over mutable subslices separated by elements that\nmatch <code>pred</code>. The matched element is contained in the previous\nsubslice as a terminator.</p>\n<h5 id=\"examples-58\"><a class=\"doc-anchor\" href=\"#examples-58\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v = [<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>, <span class=\"number\">20</span>, <span class=\"number\">60</span>, <span class=\"number\">50</span>];\n\n<span class=\"kw\">for </span>group <span class=\"kw\">in </span>v.split_inclusive_mut(|num| <span class=\"kw-2\">*</span>num % <span class=\"number\">3 </span>== <span class=\"number\">0</span>) {\n    <span class=\"kw\">let </span>terminator_idx = group.len()-<span class=\"number\">1</span>;\n    group[terminator_idx] = <span class=\"number\">1</span>;\n}\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">1</span>, <span class=\"number\">20</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.rsplit\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.27.0\">1.27.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#2319-2321\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.rsplit\" class=\"fn\">rsplit</a>&lt;F&gt;(&amp;self, pred: F) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/iter/struct.RSplit.html\" title=\"struct core::slice::iter::RSplit\">RSplit</a>&lt;'_, T, F&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns an iterator over subslices separated by elements that match\n<code>pred</code>, starting at the end of the slice and working backwards.\nThe matched element is not contained in the subslices.</p>\n<h5 id=\"examples-59\"><a class=\"doc-anchor\" href=\"#examples-59\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>slice = [<span class=\"number\">11</span>, <span class=\"number\">22</span>, <span class=\"number\">33</span>, <span class=\"number\">0</span>, <span class=\"number\">44</span>, <span class=\"number\">55</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = slice.rsplit(|num| <span class=\"kw-2\">*</span>num == <span class=\"number\">0</span>);\n\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"number\">44</span>, <span class=\"number\">55</span>]);\n<span class=\"macro\">assert_eq!</span>(iter.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"number\">11</span>, <span class=\"number\">22</span>, <span class=\"number\">33</span>]);\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">None</span>);</code></pre></div>\n<p>As with <code>split()</code>, if the first or last element is matched, an empty\nslice will be the first (or last) item returned by the iterator.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>it = v.rsplit(|n| <span class=\"kw-2\">*</span>n % <span class=\"number\">2 </span>== <span class=\"number\">0</span>);\n<span class=\"macro\">assert_eq!</span>(it.next().unwrap(), <span class=\"kw-2\">&amp;</span>[]);\n<span class=\"macro\">assert_eq!</span>(it.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"number\">3</span>, <span class=\"number\">5</span>]);\n<span class=\"macro\">assert_eq!</span>(it.next().unwrap(), <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">1</span>]);\n<span class=\"macro\">assert_eq!</span>(it.next().unwrap(), <span class=\"kw-2\">&amp;</span>[]);\n<span class=\"macro\">assert_eq!</span>(it.next(), <span class=\"prelude-val\">None</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.rsplit_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.27.0\">1.27.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#2345-2347\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.rsplit_mut\" class=\"fn\">rsplit_mut</a>&lt;F&gt;(&amp;mut self, pred: F) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/iter/struct.RSplitMut.html\" title=\"struct core::slice::iter::RSplitMut\">RSplitMut</a>&lt;'_, T, F&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns an iterator over mutable subslices separated by elements that\nmatch <code>pred</code>, starting at the end of the slice and working\nbackwards. The matched element is not contained in the subslices.</p>\n<h5 id=\"examples-60\"><a class=\"doc-anchor\" href=\"#examples-60\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v = [<span class=\"number\">100</span>, <span class=\"number\">400</span>, <span class=\"number\">300</span>, <span class=\"number\">200</span>, <span class=\"number\">600</span>, <span class=\"number\">500</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>count = <span class=\"number\">0</span>;\n<span class=\"kw\">for </span>group <span class=\"kw\">in </span>v.rsplit_mut(|num| <span class=\"kw-2\">*</span>num % <span class=\"number\">3 </span>== <span class=\"number\">0</span>) {\n    count += <span class=\"number\">1</span>;\n    group[<span class=\"number\">0</span>] = count;\n}\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"number\">3</span>, <span class=\"number\">400</span>, <span class=\"number\">300</span>, <span class=\"number\">2</span>, <span class=\"number\">600</span>, <span class=\"number\">1</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.splitn\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#2373-2375\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.splitn\" class=\"fn\">splitn</a>&lt;F&gt;(&amp;self, n: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>, pred: F) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/iter/struct.SplitN.html\" title=\"struct core::slice::iter::SplitN\">SplitN</a>&lt;'_, T, F&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns an iterator over subslices separated by elements that match\n<code>pred</code>, limited to returning at most <code>n</code> items. The matched element is\nnot contained in the subslices.</p>\n<p>The last element returned, if any, will contain the remainder of the\nslice.</p>\n<h5 id=\"examples-61\"><a class=\"doc-anchor\" href=\"#examples-61\">§</a>Examples</h5>\n<p>Print the slice split once by numbers divisible by 3 (i.e., <code>[10, 40]</code>,\n<code>[20, 60, 50]</code>):</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = [<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>, <span class=\"number\">20</span>, <span class=\"number\">60</span>, <span class=\"number\">50</span>];\n\n<span class=\"kw\">for </span>group <span class=\"kw\">in </span>v.splitn(<span class=\"number\">2</span>, |num| <span class=\"kw-2\">*</span>num % <span class=\"number\">3 </span>== <span class=\"number\">0</span>) {\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"{group:?}\"</span>);\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.splitn_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#2399-2401\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.splitn_mut\" class=\"fn\">splitn_mut</a>&lt;F&gt;(&amp;mut self, n: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>, pred: F) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/iter/struct.SplitNMut.html\" title=\"struct core::slice::iter::SplitNMut\">SplitNMut</a>&lt;'_, T, F&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns an iterator over mutable subslices separated by elements that match\n<code>pred</code>, limited to returning at most <code>n</code> items. The matched element is\nnot contained in the subslices.</p>\n<p>The last element returned, if any, will contain the remainder of the\nslice.</p>\n<h5 id=\"examples-62\"><a class=\"doc-anchor\" href=\"#examples-62\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v = [<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>, <span class=\"number\">20</span>, <span class=\"number\">60</span>, <span class=\"number\">50</span>];\n\n<span class=\"kw\">for </span>group <span class=\"kw\">in </span>v.splitn_mut(<span class=\"number\">2</span>, |num| <span class=\"kw-2\">*</span>num % <span class=\"number\">3 </span>== <span class=\"number\">0</span>) {\n    group[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;\n}\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"number\">1</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>, <span class=\"number\">1</span>, <span class=\"number\">60</span>, <span class=\"number\">50</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.rsplitn\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#2428-2430\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.rsplitn\" class=\"fn\">rsplitn</a>&lt;F&gt;(&amp;self, n: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>, pred: F) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/iter/struct.RSplitN.html\" title=\"struct core::slice::iter::RSplitN\">RSplitN</a>&lt;'_, T, F&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns an iterator over subslices separated by elements that match\n<code>pred</code> limited to returning at most <code>n</code> items. This starts at the end of\nthe slice and works backwards. The matched element is not contained in\nthe subslices.</p>\n<p>The last element returned, if any, will contain the remainder of the\nslice.</p>\n<h5 id=\"examples-63\"><a class=\"doc-anchor\" href=\"#examples-63\">§</a>Examples</h5>\n<p>Print the slice split once, starting from the end, by numbers divisible\nby 3 (i.e., <code>[50]</code>, <code>[10, 40, 30, 20]</code>):</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = [<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>, <span class=\"number\">20</span>, <span class=\"number\">60</span>, <span class=\"number\">50</span>];\n\n<span class=\"kw\">for </span>group <span class=\"kw\">in </span>v.rsplitn(<span class=\"number\">2</span>, |num| <span class=\"kw-2\">*</span>num % <span class=\"number\">3 </span>== <span class=\"number\">0</span>) {\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"{group:?}\"</span>);\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.rsplitn_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#2455-2457\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.rsplitn_mut\" class=\"fn\">rsplitn_mut</a>&lt;F&gt;(&amp;mut self, n: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>, pred: F) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/iter/struct.RSplitNMut.html\" title=\"struct core::slice::iter::RSplitNMut\">RSplitNMut</a>&lt;'_, T, F&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns an iterator over subslices separated by elements that match\n<code>pred</code> limited to returning at most <code>n</code> items. This starts at the end of\nthe slice and works backwards. The matched element is not contained in\nthe subslices.</p>\n<p>The last element returned, if any, will contain the remainder of the\nslice.</p>\n<h5 id=\"examples-64\"><a class=\"doc-anchor\" href=\"#examples-64\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = [<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>, <span class=\"number\">20</span>, <span class=\"number\">60</span>, <span class=\"number\">50</span>];\n\n<span class=\"kw\">for </span>group <span class=\"kw\">in </span>s.rsplitn_mut(<span class=\"number\">2</span>, |num| <span class=\"kw-2\">*</span>num % <span class=\"number\">3 </span>== <span class=\"number\">0</span>) {\n    group[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;\n}\n<span class=\"macro\">assert_eq!</span>(s, [<span class=\"number\">1</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>, <span class=\"number\">20</span>, <span class=\"number\">60</span>, <span class=\"number\">1</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.split_once\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#2482-2484\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.split_once\" class=\"fn\">split_once</a>&lt;F&gt;(&amp;self, pred: F) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;(&amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>, &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_split_once</code>)</span></div></span></summary><div class=\"docblock\"><p>Splits the slice on the first element that matches the specified\npredicate.</p>\n<p>If any matching elements are present in the slice, returns the prefix\nbefore the match and suffix after. The matching element itself is not\nincluded. If no elements match, returns <code>None</code>.</p>\n<h5 id=\"examples-65\"><a class=\"doc-anchor\" href=\"#examples-65\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(slice_split_once)]\n</span><span class=\"kw\">let </span>s = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>];\n<span class=\"macro\">assert_eq!</span>(s.split_once(|<span class=\"kw-2\">&amp;</span>x| x == <span class=\"number\">2</span>), <span class=\"prelude-val\">Some</span>((\n    <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>][..],\n    <span class=\"kw-2\">&amp;</span>[<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>][..]\n)));\n<span class=\"macro\">assert_eq!</span>(s.split_once(|<span class=\"kw-2\">&amp;</span>x| x == <span class=\"number\">0</span>), <span class=\"prelude-val\">None</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.rsplit_once\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#2510-2512\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.rsplit_once\" class=\"fn\">rsplit_once</a>&lt;F&gt;(&amp;self, pred: F) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;(&amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>, &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_split_once</code>)</span></div></span></summary><div class=\"docblock\"><p>Splits the slice on the last element that matches the specified\npredicate.</p>\n<p>If any matching elements are present in the slice, returns the prefix\nbefore the match and suffix after. The matching element itself is not\nincluded. If no elements match, returns <code>None</code>.</p>\n<h5 id=\"examples-66\"><a class=\"doc-anchor\" href=\"#examples-66\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(slice_split_once)]\n</span><span class=\"kw\">let </span>s = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>];\n<span class=\"macro\">assert_eq!</span>(s.rsplit_once(|<span class=\"kw-2\">&amp;</span>x| x == <span class=\"number\">2</span>), <span class=\"prelude-val\">Some</span>((\n    <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>][..],\n    <span class=\"kw-2\">&amp;</span>[<span class=\"number\">4</span>][..]\n)));\n<span class=\"macro\">assert_eq!</span>(s.rsplit_once(|<span class=\"kw-2\">&amp;</span>x| x == <span class=\"number\">0</span>), <span class=\"prelude-val\">None</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.contains\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#2546-2548\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.contains\" class=\"fn\">contains</a>(&amp;self, x: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html\" title=\"trait core::cmp::PartialEq\">PartialEq</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if the slice contains an element with the given value.</p>\n<p>This operation is <em>O</em>(<em>n</em>).</p>\n<p>Note that if you have a sorted slice, <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.binary_search\" title=\"method slice::binary_search\"><code>binary_search</code></a> may be faster.</p>\n<h5 id=\"examples-67\"><a class=\"doc-anchor\" href=\"#examples-67\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = [<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>];\n<span class=\"macro\">assert!</span>(v.contains(<span class=\"kw-2\">&amp;</span><span class=\"number\">30</span>));\n<span class=\"macro\">assert!</span>(!v.contains(<span class=\"kw-2\">&amp;</span><span class=\"number\">50</span>));</code></pre></div>\n<p>If you do not have a <code>&amp;T</code>, but some other value that you can compare\nwith one (for example, <code>String</code> implements <code>PartialEq&lt;str&gt;</code>), you can\nuse <code>iter().any</code>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = [String::from(<span class=\"string\">\"hello\"</span>), String::from(<span class=\"string\">\"world\"</span>)]; <span class=\"comment\">// slice of `String`\n</span><span class=\"macro\">assert!</span>(v.iter().any(|e| e == <span class=\"string\">\"hello\"</span>)); <span class=\"comment\">// search with `&amp;str`\n</span><span class=\"macro\">assert!</span>(!v.iter().any(|e| e == <span class=\"string\">\"hi\"</span>));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.starts_with\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#2576-2578\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.starts_with\" class=\"fn\">starts_with</a>(&amp;self, needle: &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html\" title=\"trait core::cmp::PartialEq\">PartialEq</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if <code>needle</code> is a prefix of the slice or equal to the slice.</p>\n<h5 id=\"examples-68\"><a class=\"doc-anchor\" href=\"#examples-68\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = [<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>];\n<span class=\"macro\">assert!</span>(v.starts_with(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">10</span>]));\n<span class=\"macro\">assert!</span>(v.starts_with(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">10</span>, <span class=\"number\">40</span>]));\n<span class=\"macro\">assert!</span>(v.starts_with(<span class=\"kw-2\">&amp;</span>v));\n<span class=\"macro\">assert!</span>(!v.starts_with(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">50</span>]));\n<span class=\"macro\">assert!</span>(!v.starts_with(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">10</span>, <span class=\"number\">50</span>]));</code></pre></div>\n<p>Always returns <code>true</code> if <code>needle</code> is an empty slice:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>];\n<span class=\"macro\">assert!</span>(v.starts_with(<span class=\"kw-2\">&amp;</span>[]));\n<span class=\"kw\">let </span>v: <span class=\"kw-2\">&amp;</span>[u8] = <span class=\"kw-2\">&amp;</span>[];\n<span class=\"macro\">assert!</span>(v.starts_with(<span class=\"kw-2\">&amp;</span>[]));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ends_with\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#2607-2609\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.ends_with\" class=\"fn\">ends_with</a>(&amp;self, needle: &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html\" title=\"trait core::cmp::PartialEq\">PartialEq</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if <code>needle</code> is a suffix of the slice or equal to the slice.</p>\n<h5 id=\"examples-69\"><a class=\"doc-anchor\" href=\"#examples-69\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = [<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>];\n<span class=\"macro\">assert!</span>(v.ends_with(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">30</span>]));\n<span class=\"macro\">assert!</span>(v.ends_with(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">40</span>, <span class=\"number\">30</span>]));\n<span class=\"macro\">assert!</span>(v.ends_with(<span class=\"kw-2\">&amp;</span>v));\n<span class=\"macro\">assert!</span>(!v.ends_with(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">50</span>]));\n<span class=\"macro\">assert!</span>(!v.ends_with(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">50</span>, <span class=\"number\">30</span>]));</code></pre></div>\n<p>Always returns <code>true</code> if <code>needle</code> is an empty slice:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>];\n<span class=\"macro\">assert!</span>(v.ends_with(<span class=\"kw-2\">&amp;</span>[]));\n<span class=\"kw\">let </span>v: <span class=\"kw-2\">&amp;</span>[u8] = <span class=\"kw-2\">&amp;</span>[];\n<span class=\"macro\">assert!</span>(v.ends_with(<span class=\"kw-2\">&amp;</span>[]));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.strip_prefix\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.51.0\">1.51.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#2639-2641\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.strip_prefix\" class=\"fn\">strip_prefix</a>&lt;P&gt;(&amp;self, prefix: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;P</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;&amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/trait.SlicePattern.html\" title=\"trait core::slice::SlicePattern\">SlicePattern</a>&lt;Item = T&gt; + ?<a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a>,\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html\" title=\"trait core::cmp::PartialEq\">PartialEq</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns a subslice with the prefix removed.</p>\n<p>If the slice starts with <code>prefix</code>, returns the subslice after the prefix, wrapped in <code>Some</code>.\nIf <code>prefix</code> is empty, simply returns the original slice. If <code>prefix</code> is equal to the\noriginal slice, returns an empty slice.</p>\n<p>If the slice does not start with <code>prefix</code>, returns <code>None</code>.</p>\n<h5 id=\"examples-70\"><a class=\"doc-anchor\" href=\"#examples-70\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>];\n<span class=\"macro\">assert_eq!</span>(v.strip_prefix(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">10</span>]), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">40</span>, <span class=\"number\">30</span>][..]));\n<span class=\"macro\">assert_eq!</span>(v.strip_prefix(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">10</span>, <span class=\"number\">40</span>]), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">30</span>][..]));\n<span class=\"macro\">assert_eq!</span>(v.strip_prefix(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>]), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span>[][..]));\n<span class=\"macro\">assert_eq!</span>(v.strip_prefix(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">50</span>]), <span class=\"prelude-val\">None</span>);\n<span class=\"macro\">assert_eq!</span>(v.strip_prefix(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">10</span>, <span class=\"number\">50</span>]), <span class=\"prelude-val\">None</span>);\n\n<span class=\"kw\">let </span>prefix : <span class=\"kw-2\">&amp;</span>str = <span class=\"string\">\"he\"</span>;\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">b\"hello\"</span>.strip_prefix(prefix.as_bytes()),\n           <span class=\"prelude-val\">Some</span>(<span class=\"string\">b\"llo\"</span>.as_ref()));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.strip_suffix\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.51.0\">1.51.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#2675-2677\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.strip_suffix\" class=\"fn\">strip_suffix</a>&lt;P&gt;(&amp;self, suffix: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;P</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;&amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/trait.SlicePattern.html\" title=\"trait core::slice::SlicePattern\">SlicePattern</a>&lt;Item = T&gt; + ?<a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a>,\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html\" title=\"trait core::cmp::PartialEq\">PartialEq</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns a subslice with the suffix removed.</p>\n<p>If the slice ends with <code>suffix</code>, returns the subslice before the suffix, wrapped in <code>Some</code>.\nIf <code>suffix</code> is empty, simply returns the original slice. If <code>suffix</code> is equal to the\noriginal slice, returns an empty slice.</p>\n<p>If the slice does not end with <code>suffix</code>, returns <code>None</code>.</p>\n<h5 id=\"examples-71\"><a class=\"doc-anchor\" href=\"#examples-71\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>];\n<span class=\"macro\">assert_eq!</span>(v.strip_suffix(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">30</span>]), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">10</span>, <span class=\"number\">40</span>][..]));\n<span class=\"macro\">assert_eq!</span>(v.strip_suffix(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">40</span>, <span class=\"number\">30</span>]), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">10</span>][..]));\n<span class=\"macro\">assert_eq!</span>(v.strip_suffix(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">10</span>, <span class=\"number\">40</span>, <span class=\"number\">30</span>]), <span class=\"prelude-val\">Some</span>(<span class=\"kw-2\">&amp;</span>[][..]));\n<span class=\"macro\">assert_eq!</span>(v.strip_suffix(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">50</span>]), <span class=\"prelude-val\">None</span>);\n<span class=\"macro\">assert_eq!</span>(v.strip_suffix(<span class=\"kw-2\">&amp;</span>[<span class=\"number\">50</span>, <span class=\"number\">30</span>]), <span class=\"prelude-val\">None</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.binary_search\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#2761-2763\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.binary_search\" class=\"fn\">binary_search</a>(&amp;self, x: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\">Ord</a>,</div></h4></section></summary><div class=\"docblock\"><p>Binary searches this slice for a given element.\nIf the slice is not sorted, the returned result is unspecified and\nmeaningless.</p>\n<p>If the value is found then <a href=\"https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html#variant.Ok\" title=\"variant core::result::Result::Ok\"><code>Result::Ok</code></a> is returned, containing the\nindex of the matching element. If there are multiple matches, then any\none of the matches could be returned. The index is chosen\ndeterministically, but is subject to change in future versions of Rust.\nIf the value is not found then <a href=\"https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html#variant.Err\" title=\"variant core::result::Result::Err\"><code>Result::Err</code></a> is returned, containing\nthe index where a matching element could be inserted while maintaining\nsorted order.</p>\n<p>See also <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.binary_search_by\" title=\"method slice::binary_search_by\"><code>binary_search_by</code></a>, <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.binary_search_by_key\" title=\"method slice::binary_search_by_key\"><code>binary_search_by_key</code></a>, and <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.partition_point\" title=\"method slice::partition_point\"><code>partition_point</code></a>.</p>\n<h5 id=\"examples-72\"><a class=\"doc-anchor\" href=\"#examples-72\">§</a>Examples</h5>\n<p>Looks up a series of four elements. The first is found, with a\nuniquely determined position; the second and third are not\nfound; the fourth could match any position in <code>[1, 4]</code>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">13</span>, <span class=\"number\">21</span>, <span class=\"number\">34</span>, <span class=\"number\">55</span>];\n\n<span class=\"macro\">assert_eq!</span>(s.binary_search(<span class=\"kw-2\">&amp;</span><span class=\"number\">13</span>),  <span class=\"prelude-val\">Ok</span>(<span class=\"number\">9</span>));\n<span class=\"macro\">assert_eq!</span>(s.binary_search(<span class=\"kw-2\">&amp;</span><span class=\"number\">4</span>),   <span class=\"prelude-val\">Err</span>(<span class=\"number\">7</span>));\n<span class=\"macro\">assert_eq!</span>(s.binary_search(<span class=\"kw-2\">&amp;</span><span class=\"number\">100</span>), <span class=\"prelude-val\">Err</span>(<span class=\"number\">13</span>));\n<span class=\"kw\">let </span>r = s.binary_search(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>);\n<span class=\"macro\">assert!</span>(<span class=\"kw\">match </span>r { <span class=\"prelude-val\">Ok</span>(<span class=\"number\">1</span>..=<span class=\"number\">4</span>) =&gt; <span class=\"bool-val\">true</span>, <span class=\"kw\">_ </span>=&gt; <span class=\"bool-val\">false</span>, });</code></pre></div>\n<p>If you want to find that whole <em>range</em> of matching items, rather than\nan arbitrary matching one, that can be done using <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.partition_point\" title=\"method slice::partition_point\"><code>partition_point</code></a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">13</span>, <span class=\"number\">21</span>, <span class=\"number\">34</span>, <span class=\"number\">55</span>];\n\n<span class=\"kw\">let </span>low = s.partition_point(|x| x &lt; <span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>);\n<span class=\"macro\">assert_eq!</span>(low, <span class=\"number\">1</span>);\n<span class=\"kw\">let </span>high = s.partition_point(|x| x &lt;= <span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>);\n<span class=\"macro\">assert_eq!</span>(high, <span class=\"number\">5</span>);\n<span class=\"kw\">let </span>r = s.binary_search(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>);\n<span class=\"macro\">assert!</span>((low..high).contains(<span class=\"kw-2\">&amp;</span>r.unwrap()));\n\n<span class=\"macro\">assert!</span>(s[..low].iter().all(|<span class=\"kw-2\">&amp;</span>x| x &lt; <span class=\"number\">1</span>));\n<span class=\"macro\">assert!</span>(s[low..high].iter().all(|<span class=\"kw-2\">&amp;</span>x| x == <span class=\"number\">1</span>));\n<span class=\"macro\">assert!</span>(s[high..].iter().all(|<span class=\"kw-2\">&amp;</span>x| x &gt; <span class=\"number\">1</span>));\n\n<span class=\"comment\">// For something not found, the \"range\" of equal items is empty\n</span><span class=\"macro\">assert_eq!</span>(s.partition_point(|x| x &lt; <span class=\"kw-2\">&amp;</span><span class=\"number\">11</span>), <span class=\"number\">9</span>);\n<span class=\"macro\">assert_eq!</span>(s.partition_point(|x| x &lt;= <span class=\"kw-2\">&amp;</span><span class=\"number\">11</span>), <span class=\"number\">9</span>);\n<span class=\"macro\">assert_eq!</span>(s.binary_search(<span class=\"kw-2\">&amp;</span><span class=\"number\">11</span>), <span class=\"prelude-val\">Err</span>(<span class=\"number\">9</span>));</code></pre></div>\n<p>If you want to insert an item to a sorted vector, while maintaining\nsort order, consider using <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.partition_point\" title=\"method slice::partition_point\"><code>partition_point</code></a>:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = <span class=\"macro\">vec!</span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">13</span>, <span class=\"number\">21</span>, <span class=\"number\">34</span>, <span class=\"number\">55</span>];\n<span class=\"kw\">let </span>num = <span class=\"number\">42</span>;\n<span class=\"kw\">let </span>idx = s.partition_point(|<span class=\"kw-2\">&amp;</span>x| x &lt;= num);\n<span class=\"comment\">// If `num` is unique, `s.partition_point(|&amp;x| x &lt; num)` (with `&lt;`) is equivalent to\n// `s.binary_search(&amp;num).unwrap_or_else(|x| x)`, but using `&lt;=` will allow `insert`\n// to shift less elements.\n</span>s.insert(idx, num);\n<span class=\"macro\">assert_eq!</span>(s, [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">13</span>, <span class=\"number\">21</span>, <span class=\"number\">34</span>, <span class=\"number\">42</span>, <span class=\"number\">55</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.binary_search_by\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#2812-2814\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.binary_search_by\" class=\"fn\">binary_search_by</a>&lt;'a, F&gt;(&amp;'a self, f: F) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;'a T</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/enum.Ordering.html\" title=\"enum core::cmp::Ordering\">Ordering</a>,</div></h4></section></summary><div class=\"docblock\"><p>Binary searches this slice with a comparator function.</p>\n<p>The comparator function should return an order code that indicates\nwhether its argument is <code>Less</code>, <code>Equal</code> or <code>Greater</code> the desired\ntarget.\nIf the slice is not sorted or if the comparator function does not\nimplement an order consistent with the sort order of the underlying\nslice, the returned result is unspecified and meaningless.</p>\n<p>If the value is found then <a href=\"https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html#variant.Ok\" title=\"variant core::result::Result::Ok\"><code>Result::Ok</code></a> is returned, containing the\nindex of the matching element. If there are multiple matches, then any\none of the matches could be returned. The index is chosen\ndeterministically, but is subject to change in future versions of Rust.\nIf the value is not found then <a href=\"https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html#variant.Err\" title=\"variant core::result::Result::Err\"><code>Result::Err</code></a> is returned, containing\nthe index where a matching element could be inserted while maintaining\nsorted order.</p>\n<p>See also <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.binary_search\" title=\"method slice::binary_search\"><code>binary_search</code></a>, <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.binary_search_by_key\" title=\"method slice::binary_search_by_key\"><code>binary_search_by_key</code></a>, and <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.partition_point\" title=\"method slice::partition_point\"><code>partition_point</code></a>.</p>\n<h5 id=\"examples-73\"><a class=\"doc-anchor\" href=\"#examples-73\">§</a>Examples</h5>\n<p>Looks up a series of four elements. The first is found, with a\nuniquely determined position; the second and third are not\nfound; the fourth could match any position in <code>[1, 4]</code>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">13</span>, <span class=\"number\">21</span>, <span class=\"number\">34</span>, <span class=\"number\">55</span>];\n\n<span class=\"kw\">let </span>seek = <span class=\"number\">13</span>;\n<span class=\"macro\">assert_eq!</span>(s.binary_search_by(|probe| probe.cmp(<span class=\"kw-2\">&amp;</span>seek)), <span class=\"prelude-val\">Ok</span>(<span class=\"number\">9</span>));\n<span class=\"kw\">let </span>seek = <span class=\"number\">4</span>;\n<span class=\"macro\">assert_eq!</span>(s.binary_search_by(|probe| probe.cmp(<span class=\"kw-2\">&amp;</span>seek)), <span class=\"prelude-val\">Err</span>(<span class=\"number\">7</span>));\n<span class=\"kw\">let </span>seek = <span class=\"number\">100</span>;\n<span class=\"macro\">assert_eq!</span>(s.binary_search_by(|probe| probe.cmp(<span class=\"kw-2\">&amp;</span>seek)), <span class=\"prelude-val\">Err</span>(<span class=\"number\">13</span>));\n<span class=\"kw\">let </span>seek = <span class=\"number\">1</span>;\n<span class=\"kw\">let </span>r = s.binary_search_by(|probe| probe.cmp(<span class=\"kw-2\">&amp;</span>seek));\n<span class=\"macro\">assert!</span>(<span class=\"kw\">match </span>r { <span class=\"prelude-val\">Ok</span>(<span class=\"number\">1</span>..=<span class=\"number\">4</span>) =&gt; <span class=\"bool-val\">true</span>, <span class=\"kw\">_ </span>=&gt; <span class=\"bool-val\">false</span>, });</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.binary_search_by_key\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#2913-2916\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.binary_search_by_key\" class=\"fn\">binary_search_by_key</a>&lt;'a, B, F&gt;(\n    &amp;'a self,\n    b: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;B</a>,\n    f: F,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;'a T</a>) -&gt; B,\n    B: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\">Ord</a>,</div></h4></section></summary><div class=\"docblock\"><p>Binary searches this slice with a key extraction function.</p>\n<p>Assumes that the slice is sorted by the key, for instance with\n<a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.sort_by_key\" title=\"method slice::sort_by_key\"><code>sort_by_key</code></a> using the same key extraction function.\nIf the slice is not sorted by the key, the returned result is\nunspecified and meaningless.</p>\n<p>If the value is found then <a href=\"https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html#variant.Ok\" title=\"variant core::result::Result::Ok\"><code>Result::Ok</code></a> is returned, containing the\nindex of the matching element. If there are multiple matches, then any\none of the matches could be returned. The index is chosen\ndeterministically, but is subject to change in future versions of Rust.\nIf the value is not found then <a href=\"https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html#variant.Err\" title=\"variant core::result::Result::Err\"><code>Result::Err</code></a> is returned, containing\nthe index where a matching element could be inserted while maintaining\nsorted order.</p>\n<p>See also <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.binary_search\" title=\"method slice::binary_search\"><code>binary_search</code></a>, <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.binary_search_by\" title=\"method slice::binary_search_by\"><code>binary_search_by</code></a>, and <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.partition_point\" title=\"method slice::partition_point\"><code>partition_point</code></a>.</p>\n<h5 id=\"examples-74\"><a class=\"doc-anchor\" href=\"#examples-74\">§</a>Examples</h5>\n<p>Looks up a series of four elements in a slice of pairs sorted by\ntheir second elements. The first is found, with a uniquely\ndetermined position; the second and third are not found; the\nfourth could match any position in <code>[1, 4]</code>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>s = [(<span class=\"number\">0</span>, <span class=\"number\">0</span>), (<span class=\"number\">2</span>, <span class=\"number\">1</span>), (<span class=\"number\">4</span>, <span class=\"number\">1</span>), (<span class=\"number\">5</span>, <span class=\"number\">1</span>), (<span class=\"number\">3</span>, <span class=\"number\">1</span>),\n         (<span class=\"number\">1</span>, <span class=\"number\">2</span>), (<span class=\"number\">2</span>, <span class=\"number\">3</span>), (<span class=\"number\">4</span>, <span class=\"number\">5</span>), (<span class=\"number\">5</span>, <span class=\"number\">8</span>), (<span class=\"number\">3</span>, <span class=\"number\">13</span>),\n         (<span class=\"number\">1</span>, <span class=\"number\">21</span>), (<span class=\"number\">2</span>, <span class=\"number\">34</span>), (<span class=\"number\">4</span>, <span class=\"number\">55</span>)];\n\n<span class=\"macro\">assert_eq!</span>(s.binary_search_by_key(<span class=\"kw-2\">&amp;</span><span class=\"number\">13</span>, |<span class=\"kw-2\">&amp;</span>(a, b)| b),  <span class=\"prelude-val\">Ok</span>(<span class=\"number\">9</span>));\n<span class=\"macro\">assert_eq!</span>(s.binary_search_by_key(<span class=\"kw-2\">&amp;</span><span class=\"number\">4</span>, |<span class=\"kw-2\">&amp;</span>(a, b)| b),   <span class=\"prelude-val\">Err</span>(<span class=\"number\">7</span>));\n<span class=\"macro\">assert_eq!</span>(s.binary_search_by_key(<span class=\"kw-2\">&amp;</span><span class=\"number\">100</span>, |<span class=\"kw-2\">&amp;</span>(a, b)| b), <span class=\"prelude-val\">Err</span>(<span class=\"number\">13</span>));\n<span class=\"kw\">let </span>r = s.binary_search_by_key(<span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>, |<span class=\"kw-2\">&amp;</span>(a, b)| b);\n<span class=\"macro\">assert!</span>(<span class=\"kw\">match </span>r { <span class=\"prelude-val\">Ok</span>(<span class=\"number\">1</span>..=<span class=\"number\">4</span>) =&gt; <span class=\"bool-val\">true</span>, <span class=\"kw\">_ </span>=&gt; <span class=\"bool-val\">false</span>, });</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.sort_unstable\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.20.0\">1.20.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#2967-2969\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.sort_unstable\" class=\"fn\">sort_unstable</a>(&amp;mut self)<div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\">Ord</a>,</div></h4></section></summary><div class=\"docblock\"><p>Sorts the slice <strong>without</strong> preserving the initial order of equal elements.</p>\n<p>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not\nallocate), and <em>O</em>(<em>n</em> * log(<em>n</em>)) worst-case.</p>\n<p>If the implementation of <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\"><code>Ord</code></a> for <code>T</code> does not implement a <a href=\"https://en.wikipedia.org/wiki/Total_order\">total order</a> the resulting\norder of elements in the slice is unspecified. All original elements will remain in the\nslice and any possible modifications via interior mutability are observed in the input. Same\nis true if the implementation of <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\"><code>Ord</code></a> for <code>T</code> panics.</p>\n<p>Sorting types that only implement <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html\" title=\"trait core::cmp::PartialOrd\"><code>PartialOrd</code></a> such as <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.f32.html\" title=\"primitive f32\"><code>f32</code></a> and <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.f64.html\" title=\"primitive f64\"><code>f64</code></a> require\nadditional precautions. For example, <code>f32::NAN != f32::NAN</code>, which doesn’t fulfill the\nreflexivity requirement of <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\"><code>Ord</code></a>. By using an alternative comparison function with\n<code>slice::sort_unstable_by</code> such as <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.f32.html#method.total_cmp\" title=\"method f32::total_cmp\"><code>f32::total_cmp</code></a> or <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.f64.html#method.total_cmp\" title=\"method f64::total_cmp\"><code>f64::total_cmp</code></a> that defines a\n<a href=\"https://en.wikipedia.org/wiki/Total_order\">total order</a> users can sort slices containing floating-point values. Alternatively, if all\nvalues in the slice are guaranteed to be in a subset for which <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp\" title=\"method core::cmp::PartialOrd::partial_cmp\"><code>PartialOrd::partial_cmp</code></a>\nforms a <a href=\"https://en.wikipedia.org/wiki/Total_order\">total order</a>, it’s possible to sort the slice with <code>sort_unstable_by(|a, b| a.partial_cmp(b).unwrap())</code>.</p>\n<h5 id=\"current-implementation\"><a class=\"doc-anchor\" href=\"#current-implementation\">§</a>Current implementation</h5>\n<p>The current implementation is based on <a href=\"https://github.com/Voultapher/sort-research-rs/tree/main/ipnsort\">ipnsort</a> by Lukas Bergdoll and Orson Peters, which\ncombines the fast average case of quicksort with the fast worst case of heapsort, achieving\nlinear time on fully sorted and reversed inputs. On inputs with k distinct elements, the\nexpected time to sort the data is <em>O</em>(<em>n</em> * log(<em>k</em>)).</p>\n<p>It is typically faster than stable sorting, except in a few special cases, e.g., when the\nslice is partially sorted.</p>\n<h5 id=\"panics-19\"><a class=\"doc-anchor\" href=\"#panics-19\">§</a>Panics</h5>\n<p>May panic if the implementation of <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\"><code>Ord</code></a> for <code>T</code> does not implement a <a href=\"https://en.wikipedia.org/wiki/Total_order\">total order</a>.</p>\n<h5 id=\"examples-75\"><a class=\"doc-anchor\" href=\"#examples-75\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v = [<span class=\"number\">4</span>, -<span class=\"number\">5</span>, <span class=\"number\">1</span>, -<span class=\"number\">3</span>, <span class=\"number\">2</span>];\n\nv.sort_unstable();\n<span class=\"macro\">assert_eq!</span>(v, [-<span class=\"number\">5</span>, -<span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.sort_unstable_by\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.20.0\">1.20.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#3019-3021\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.sort_unstable_by\" class=\"fn\">sort_unstable_by</a>&lt;F&gt;(&amp;mut self, compare: F)<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/enum.Ordering.html\" title=\"enum core::cmp::Ordering\">Ordering</a>,</div></h4></section></summary><div class=\"docblock\"><p>Sorts the slice with a comparison function, <strong>without</strong> preserving the initial order of\nequal elements.</p>\n<p>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not\nallocate), and <em>O</em>(<em>n</em> * log(<em>n</em>)) worst-case.</p>\n<p>If the comparison function <code>compare</code> does not implement a <a href=\"https://en.wikipedia.org/wiki/Total_order\">total order</a> the resulting order\nof elements in the slice is unspecified. All original elements will remain in the slice and\nany possible modifications via interior mutability are observed in the input. Same is true\nif <code>compare</code> panics.</p>\n<p>For example <code>|a, b| (a - b).cmp(a)</code> is a comparison function that is neither transitive nor\nreflexive nor total, <code>a &lt; b &lt; c &lt; a</code> with <code>a = 1, b = 2, c = 3</code>. For more information and\nexamples see the <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\"><code>Ord</code></a> documentation.</p>\n<h5 id=\"current-implementation-1\"><a class=\"doc-anchor\" href=\"#current-implementation-1\">§</a>Current implementation</h5>\n<p>The current implementation is based on <a href=\"https://github.com/Voultapher/sort-research-rs/tree/main/ipnsort\">ipnsort</a> by Lukas Bergdoll and Orson Peters, which\ncombines the fast average case of quicksort with the fast worst case of heapsort, achieving\nlinear time on fully sorted and reversed inputs. On inputs with k distinct elements, the\nexpected time to sort the data is <em>O</em>(<em>n</em> * log(<em>k</em>)).</p>\n<p>It is typically faster than stable sorting, except in a few special cases, e.g., when the\nslice is partially sorted.</p>\n<h5 id=\"panics-20\"><a class=\"doc-anchor\" href=\"#panics-20\">§</a>Panics</h5>\n<p>May panic if <code>compare</code> does not implement a <a href=\"https://en.wikipedia.org/wiki/Total_order\">total order</a>.</p>\n<h5 id=\"examples-76\"><a class=\"doc-anchor\" href=\"#examples-76\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v = [<span class=\"number\">4</span>, -<span class=\"number\">5</span>, <span class=\"number\">1</span>, -<span class=\"number\">3</span>, <span class=\"number\">2</span>];\nv.sort_unstable_by(|a, b| a.cmp(b));\n<span class=\"macro\">assert_eq!</span>(v, [-<span class=\"number\">5</span>, -<span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>]);\n\n<span class=\"comment\">// reverse sorting\n</span>v.sort_unstable_by(|a, b| b.cmp(a));\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, -<span class=\"number\">3</span>, -<span class=\"number\">5</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.sort_unstable_by_key\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.20.0\">1.20.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#3064-3067\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.sort_unstable_by_key\" class=\"fn\">sort_unstable_by_key</a>&lt;K, F&gt;(&amp;mut self, f: F)<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>) -&gt; K,\n    K: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\">Ord</a>,</div></h4></section></summary><div class=\"docblock\"><p>Sorts the slice with a key extraction function, <strong>without</strong> preserving the initial order of\nequal elements.</p>\n<p>This sort is unstable (i.e., may reorder equal elements), in-place (i.e., does not\nallocate), and <em>O</em>(<em>n</em> * log(<em>n</em>)) worst-case.</p>\n<p>If the implementation of <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\"><code>Ord</code></a> for <code>K</code> does not implement a <a href=\"https://en.wikipedia.org/wiki/Total_order\">total order</a> the resulting\norder of elements in the slice is unspecified. All original elements will remain in the\nslice and any possible modifications via interior mutability are observed in the input. Same\nis true if the implementation of <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\"><code>Ord</code></a> for <code>K</code> panics.</p>\n<h5 id=\"current-implementation-2\"><a class=\"doc-anchor\" href=\"#current-implementation-2\">§</a>Current implementation</h5>\n<p>The current implementation is based on <a href=\"https://github.com/Voultapher/sort-research-rs/tree/main/ipnsort\">ipnsort</a> by Lukas Bergdoll and Orson Peters, which\ncombines the fast average case of quicksort with the fast worst case of heapsort, achieving\nlinear time on fully sorted and reversed inputs. On inputs with k distinct elements, the\nexpected time to sort the data is <em>O</em>(<em>n</em> * log(<em>k</em>)).</p>\n<p>It is typically faster than stable sorting, except in a few special cases, e.g., when the\nslice is partially sorted.</p>\n<h5 id=\"panics-21\"><a class=\"doc-anchor\" href=\"#panics-21\">§</a>Panics</h5>\n<p>May panic if the implementation of <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\"><code>Ord</code></a> for <code>K</code> does not implement a <a href=\"https://en.wikipedia.org/wiki/Total_order\">total order</a>.</p>\n<h5 id=\"examples-77\"><a class=\"doc-anchor\" href=\"#examples-77\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v = [<span class=\"number\">4i32</span>, -<span class=\"number\">5</span>, <span class=\"number\">1</span>, -<span class=\"number\">3</span>, <span class=\"number\">2</span>];\n\nv.sort_unstable_by_key(|k| k.abs());\n<span class=\"macro\">assert_eq!</span>(v, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, -<span class=\"number\">3</span>, <span class=\"number\">4</span>, -<span class=\"number\">5</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.select_nth_unstable\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.49.0\">1.49.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#3126-3128\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.select_nth_unstable\" class=\"fn\">select_nth_unstable</a>(\n    &amp;mut self,\n    index: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>,\n) -&gt; (&amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;mut T</a>, &amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)<div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\">Ord</a>,</div></h4></section></summary><div class=\"docblock\"><p>Reorders the slice such that the element at <code>index</code> after the reordering is at its final\nsorted position.</p>\n<p>This reordering has the additional property that any value at position <code>i &lt; index</code> will be\nless than or equal to any value at a position <code>j &gt; index</code>. Additionally, this reordering is\nunstable (i.e. any number of equal elements may end up at position <code>index</code>), in-place (i.e.\ndoes not allocate), and runs in <em>O</em>(<em>n</em>) time. This function is also known as “kth element”\nin other libraries.</p>\n<p>It returns a triplet of the following from the reordered slice: the subslice prior to\n<code>index</code>, the element at <code>index</code>, and the subslice after <code>index</code>; accordingly, the values in\nthose two subslices will respectively all be less-than-or-equal-to and\ngreater-than-or-equal-to the value of the element at <code>index</code>.</p>\n<h5 id=\"current-implementation-3\"><a class=\"doc-anchor\" href=\"#current-implementation-3\">§</a>Current implementation</h5>\n<p>The current algorithm is an introselect implementation based on <a href=\"https://github.com/Voultapher/sort-research-rs/tree/main/ipnsort\">ipnsort</a> by Lukas Bergdoll\nand Orson Peters, which is also the basis for <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.sort_unstable\" title=\"method slice::sort_unstable\"><code>sort_unstable</code></a>. The fallback algorithm is\nMedian of Medians using Tukey’s Ninther for pivot selection, which guarantees linear runtime\nfor all inputs.</p>\n<h5 id=\"panics-22\"><a class=\"doc-anchor\" href=\"#panics-22\">§</a>Panics</h5>\n<p>Panics when <code>index &gt;= len()</code>, meaning it always panics on empty slices.</p>\n<p>May panic if the implementation of <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\"><code>Ord</code></a> for <code>T</code> does not implement a <a href=\"https://en.wikipedia.org/wiki/Total_order\">total order</a>.</p>\n<h5 id=\"examples-78\"><a class=\"doc-anchor\" href=\"#examples-78\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v = [-<span class=\"number\">5i32</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, -<span class=\"number\">3</span>, <span class=\"number\">1</span>];\n\n<span class=\"comment\">// Find the items less than or equal to the median, the median, and greater than or equal to\n// the median.\n</span><span class=\"kw\">let </span>(lesser, median, greater) = v.select_nth_unstable(<span class=\"number\">2</span>);\n\n<span class=\"macro\">assert!</span>(lesser == [-<span class=\"number\">3</span>, -<span class=\"number\">5</span>] || lesser == [-<span class=\"number\">5</span>, -<span class=\"number\">3</span>]);\n<span class=\"macro\">assert_eq!</span>(median, <span class=\"kw-2\">&amp;mut </span><span class=\"number\">1</span>);\n<span class=\"macro\">assert!</span>(greater == [<span class=\"number\">4</span>, <span class=\"number\">2</span>] || greater == [<span class=\"number\">2</span>, <span class=\"number\">4</span>]);\n\n<span class=\"comment\">// We are only guaranteed the slice will be one of the following, based on the way we sort\n// about the specified index.\n</span><span class=\"macro\">assert!</span>(v == [-<span class=\"number\">3</span>, -<span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>] ||\n        v == [-<span class=\"number\">5</span>, -<span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>] ||\n        v == [-<span class=\"number\">3</span>, -<span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>] ||\n        v == [-<span class=\"number\">5</span>, -<span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.select_nth_unstable_by\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.49.0\">1.49.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#3187-3193\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.select_nth_unstable_by\" class=\"fn\">select_nth_unstable_by</a>&lt;F&gt;(\n    &amp;mut self,\n    index: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>,\n    compare: F,\n) -&gt; (&amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;mut T</a>, &amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/enum.Ordering.html\" title=\"enum core::cmp::Ordering\">Ordering</a>,</div></h4></section></summary><div class=\"docblock\"><p>Reorders the slice with a comparator function such that the element at <code>index</code> after the\nreordering is at its final sorted position.</p>\n<p>This reordering has the additional property that any value at position <code>i &lt; index</code> will be\nless than or equal to any value at a position <code>j &gt; index</code> using the comparator function.\nAdditionally, this reordering is unstable (i.e. any number of equal elements may end up at\nposition <code>index</code>), in-place (i.e. does not allocate), and runs in <em>O</em>(<em>n</em>) time. This\nfunction is also known as “kth element” in other libraries.</p>\n<p>It returns a triplet of the following from the slice reordered according to the provided\ncomparator function: the subslice prior to <code>index</code>, the element at <code>index</code>, and the subslice\nafter <code>index</code>; accordingly, the values in those two subslices will respectively all be\nless-than-or-equal-to and greater-than-or-equal-to the value of the element at <code>index</code>.</p>\n<h5 id=\"current-implementation-4\"><a class=\"doc-anchor\" href=\"#current-implementation-4\">§</a>Current implementation</h5>\n<p>The current algorithm is an introselect implementation based on <a href=\"https://github.com/Voultapher/sort-research-rs/tree/main/ipnsort\">ipnsort</a> by Lukas Bergdoll\nand Orson Peters, which is also the basis for <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.sort_unstable\" title=\"method slice::sort_unstable\"><code>sort_unstable</code></a>. The fallback algorithm is\nMedian of Medians using Tukey’s Ninther for pivot selection, which guarantees linear runtime\nfor all inputs.</p>\n<h5 id=\"panics-23\"><a class=\"doc-anchor\" href=\"#panics-23\">§</a>Panics</h5>\n<p>Panics when <code>index &gt;= len()</code>, meaning it always panics on empty slices.</p>\n<p>May panic if <code>compare</code> does not implement a <a href=\"https://en.wikipedia.org/wiki/Total_order\">total order</a>.</p>\n<h5 id=\"examples-79\"><a class=\"doc-anchor\" href=\"#examples-79\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v = [-<span class=\"number\">5i32</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, -<span class=\"number\">3</span>, <span class=\"number\">1</span>];\n\n<span class=\"comment\">// Find the items less than or equal to the median, the median, and greater than or equal to\n// the median as if the slice were sorted in descending order.\n</span><span class=\"kw\">let </span>(lesser, median, greater) = v.select_nth_unstable_by(<span class=\"number\">2</span>, |a, b| b.cmp(a));\n\n<span class=\"macro\">assert!</span>(lesser == [<span class=\"number\">4</span>, <span class=\"number\">2</span>] || lesser == [<span class=\"number\">2</span>, <span class=\"number\">4</span>]);\n<span class=\"macro\">assert_eq!</span>(median, <span class=\"kw-2\">&amp;mut </span><span class=\"number\">1</span>);\n<span class=\"macro\">assert!</span>(greater == [-<span class=\"number\">3</span>, -<span class=\"number\">5</span>] || greater == [-<span class=\"number\">5</span>, -<span class=\"number\">3</span>]);\n\n<span class=\"comment\">// We are only guaranteed the slice will be one of the following, based on the way we sort\n// about the specified index.\n</span><span class=\"macro\">assert!</span>(v == [<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, -<span class=\"number\">5</span>, -<span class=\"number\">3</span>] ||\n        v == [<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, -<span class=\"number\">3</span>, -<span class=\"number\">5</span>] ||\n        v == [<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, -<span class=\"number\">5</span>, -<span class=\"number\">3</span>] ||\n        v == [<span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, -<span class=\"number\">3</span>, -<span class=\"number\">5</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.select_nth_unstable_by_key\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.49.0\">1.49.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#3252-3259\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.select_nth_unstable_by_key\" class=\"fn\">select_nth_unstable_by_key</a>&lt;K, F&gt;(\n    &amp;mut self,\n    index: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>,\n    f: F,\n) -&gt; (&amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;mut T</a>, &amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>) -&gt; K,\n    K: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\">Ord</a>,</div></h4></section></summary><div class=\"docblock\"><p>Reorders the slice with a key extraction function such that the element at <code>index</code> after the\nreordering is at its final sorted position.</p>\n<p>This reordering has the additional property that any value at position <code>i &lt; index</code> will be\nless than or equal to any value at a position <code>j &gt; index</code> using the key extraction function.\nAdditionally, this reordering is unstable (i.e. any number of equal elements may end up at\nposition <code>index</code>), in-place (i.e. does not allocate), and runs in <em>O</em>(<em>n</em>) time. This\nfunction is also known as “kth element” in other libraries.</p>\n<p>It returns a triplet of the following from the slice reordered according to the provided key\nextraction function: the subslice prior to <code>index</code>, the element at <code>index</code>, and the subslice\nafter <code>index</code>; accordingly, the values in those two subslices will respectively all be\nless-than-or-equal-to and greater-than-or-equal-to the value of the element at <code>index</code>.</p>\n<h5 id=\"current-implementation-5\"><a class=\"doc-anchor\" href=\"#current-implementation-5\">§</a>Current implementation</h5>\n<p>The current algorithm is an introselect implementation based on <a href=\"https://github.com/Voultapher/sort-research-rs/tree/main/ipnsort\">ipnsort</a> by Lukas Bergdoll\nand Orson Peters, which is also the basis for <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.sort_unstable\" title=\"method slice::sort_unstable\"><code>sort_unstable</code></a>. The fallback algorithm is\nMedian of Medians using Tukey’s Ninther for pivot selection, which guarantees linear runtime\nfor all inputs.</p>\n<h5 id=\"panics-24\"><a class=\"doc-anchor\" href=\"#panics-24\">§</a>Panics</h5>\n<p>Panics when <code>index &gt;= len()</code>, meaning it always panics on empty slices.</p>\n<p>May panic if <code>K: Ord</code> does not implement a total order.</p>\n<h5 id=\"examples-80\"><a class=\"doc-anchor\" href=\"#examples-80\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>v = [-<span class=\"number\">5i32</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, -<span class=\"number\">3</span>, <span class=\"number\">2</span>];\n\n<span class=\"comment\">// Find the items less than or equal to the median, the median, and greater than or equal to\n// the median as if the slice were sorted according to absolute value.\n</span><span class=\"kw\">let </span>(lesser, median, greater) = v.select_nth_unstable_by_key(<span class=\"number\">2</span>, |a| a.abs());\n\n<span class=\"macro\">assert!</span>(lesser == [<span class=\"number\">1</span>, <span class=\"number\">2</span>] || lesser == [<span class=\"number\">2</span>, <span class=\"number\">1</span>]);\n<span class=\"macro\">assert_eq!</span>(median, <span class=\"kw-2\">&amp;mut </span>-<span class=\"number\">3</span>);\n<span class=\"macro\">assert!</span>(greater == [<span class=\"number\">4</span>, -<span class=\"number\">5</span>] || greater == [-<span class=\"number\">5</span>, <span class=\"number\">4</span>]);\n\n<span class=\"comment\">// We are only guaranteed the slice will be one of the following, based on the way we sort\n// about the specified index.\n</span><span class=\"macro\">assert!</span>(v == [<span class=\"number\">1</span>, <span class=\"number\">2</span>, -<span class=\"number\">3</span>, <span class=\"number\">4</span>, -<span class=\"number\">5</span>] ||\n        v == [<span class=\"number\">1</span>, <span class=\"number\">2</span>, -<span class=\"number\">3</span>, -<span class=\"number\">5</span>, <span class=\"number\">4</span>] ||\n        v == [<span class=\"number\">2</span>, <span class=\"number\">1</span>, -<span class=\"number\">3</span>, <span class=\"number\">4</span>, -<span class=\"number\">5</span>] ||\n        v == [<span class=\"number\">2</span>, <span class=\"number\">1</span>, -<span class=\"number\">3</span>, -<span class=\"number\">5</span>, <span class=\"number\">4</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.partition_dedup\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#3286-3288\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.partition_dedup\" class=\"fn\">partition_dedup</a>(&amp;mut self) -&gt; (&amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>, &amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)<div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html\" title=\"trait core::cmp::PartialEq\">PartialEq</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_partition_dedup</code>)</span></div></span></summary><div class=\"docblock\"><p>Moves all consecutive repeated elements to the end of the slice according to the\n<a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html\" title=\"trait core::cmp::PartialEq\"><code>PartialEq</code></a> trait implementation.</p>\n<p>Returns two slices. The first contains no consecutive repeated elements.\nThe second contains all the duplicates in no specified order.</p>\n<p>If the slice is sorted, the first returned slice contains no duplicates.</p>\n<h5 id=\"examples-81\"><a class=\"doc-anchor\" href=\"#examples-81\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(slice_partition_dedup)]\n\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>slice = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>];\n\n<span class=\"kw\">let </span>(dedup, duplicates) = slice.partition_dedup();\n\n<span class=\"macro\">assert_eq!</span>(dedup, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>]);\n<span class=\"macro\">assert_eq!</span>(duplicates, [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.partition_dedup_by\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#3320-3322\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.partition_dedup_by\" class=\"fn\">partition_dedup_by</a>&lt;F&gt;(&amp;mut self, same_bucket: F) -&gt; (&amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>, &amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;mut T</a>, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;mut T</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_partition_dedup</code>)</span></div></span></summary><div class=\"docblock\"><p>Moves all but the first of consecutive elements to the end of the slice satisfying\na given equality relation.</p>\n<p>Returns two slices. The first contains no consecutive repeated elements.\nThe second contains all the duplicates in no specified order.</p>\n<p>The <code>same_bucket</code> function is passed references to two elements from the slice and\nmust determine if the elements compare equal. The elements are passed in opposite order\nfrom their order in the slice, so if <code>same_bucket(a, b)</code> returns <code>true</code>, <code>a</code> is moved\nat the end of the slice.</p>\n<p>If the slice is sorted, the first returned slice contains no duplicates.</p>\n<h5 id=\"examples-82\"><a class=\"doc-anchor\" href=\"#examples-82\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(slice_partition_dedup)]\n\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>slice = [<span class=\"string\">\"foo\"</span>, <span class=\"string\">\"Foo\"</span>, <span class=\"string\">\"BAZ\"</span>, <span class=\"string\">\"Bar\"</span>, <span class=\"string\">\"bar\"</span>, <span class=\"string\">\"baz\"</span>, <span class=\"string\">\"BAZ\"</span>];\n\n<span class=\"kw\">let </span>(dedup, duplicates) = slice.partition_dedup_by(|a, b| a.eq_ignore_ascii_case(b));\n\n<span class=\"macro\">assert_eq!</span>(dedup, [<span class=\"string\">\"foo\"</span>, <span class=\"string\">\"BAZ\"</span>, <span class=\"string\">\"Bar\"</span>, <span class=\"string\">\"baz\"</span>]);\n<span class=\"macro\">assert_eq!</span>(duplicates, [<span class=\"string\">\"bar\"</span>, <span class=\"string\">\"Foo\"</span>, <span class=\"string\">\"BAZ\"</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.partition_dedup_by_key\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#3446-3449\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.partition_dedup_by_key\" class=\"fn\">partition_dedup_by_key</a>&lt;K, F&gt;(&amp;mut self, key: F) -&gt; (&amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>, &amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;mut T</a>) -&gt; K,\n    K: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html\" title=\"trait core::cmp::PartialEq\">PartialEq</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_partition_dedup</code>)</span></div></span></summary><div class=\"docblock\"><p>Moves all but the first of consecutive elements to the end of the slice that resolve\nto the same key.</p>\n<p>Returns two slices. The first contains no consecutive repeated elements.\nThe second contains all the duplicates in no specified order.</p>\n<p>If the slice is sorted, the first returned slice contains no duplicates.</p>\n<h5 id=\"examples-83\"><a class=\"doc-anchor\" href=\"#examples-83\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(slice_partition_dedup)]\n\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>slice = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">21</span>, <span class=\"number\">30</span>, <span class=\"number\">30</span>, <span class=\"number\">20</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>];\n\n<span class=\"kw\">let </span>(dedup, duplicates) = slice.partition_dedup_by_key(|i| <span class=\"kw-2\">*</span>i / <span class=\"number\">10</span>);\n\n<span class=\"macro\">assert_eq!</span>(dedup, [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">20</span>, <span class=\"number\">11</span>]);\n<span class=\"macro\">assert_eq!</span>(duplicates, [<span class=\"number\">21</span>, <span class=\"number\">30</span>, <span class=\"number\">13</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.rotate_left\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.26.0\">1.26.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#3487\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.rotate_left\" class=\"fn\">rotate_left</a>(&amp;mut self, mid: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>)</h4></section></summary><div class=\"docblock\"><p>Rotates the slice in-place such that the first <code>mid</code> elements of the\nslice move to the end while the last <code>self.len() - mid</code> elements move to\nthe front.</p>\n<p>After calling <code>rotate_left</code>, the element previously at index <code>mid</code> will\nbecome the first element in the slice.</p>\n<h5 id=\"panics-25\"><a class=\"doc-anchor\" href=\"#panics-25\">§</a>Panics</h5>\n<p>This function will panic if <code>mid</code> is greater than the length of the\nslice. Note that <code>mid == self.len()</code> does <em>not</em> panic and is a no-op\nrotation.</p>\n<h5 id=\"complexity\"><a class=\"doc-anchor\" href=\"#complexity\">§</a>Complexity</h5>\n<p>Takes linear (in <code>self.len()</code>) time.</p>\n<h5 id=\"examples-84\"><a class=\"doc-anchor\" href=\"#examples-84\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>a = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'f'</span>];\na.rotate_left(<span class=\"number\">2</span>);\n<span class=\"macro\">assert_eq!</span>(a, [<span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'f'</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>]);</code></pre></div>\n<p>Rotating a subslice:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>a = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'f'</span>];\na[<span class=\"number\">1</span>..<span class=\"number\">5</span>].rotate_left(<span class=\"number\">1</span>);\n<span class=\"macro\">assert_eq!</span>(a, [<span class=\"string\">'a'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'f'</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.rotate_right\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.26.0\">1.26.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#3532\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.rotate_right\" class=\"fn\">rotate_right</a>(&amp;mut self, k: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>)</h4></section></summary><div class=\"docblock\"><p>Rotates the slice in-place such that the first <code>self.len() - k</code>\nelements of the slice move to the end while the last <code>k</code> elements move\nto the front.</p>\n<p>After calling <code>rotate_right</code>, the element previously at index\n<code>self.len() - k</code> will become the first element in the slice.</p>\n<h5 id=\"panics-26\"><a class=\"doc-anchor\" href=\"#panics-26\">§</a>Panics</h5>\n<p>This function will panic if <code>k</code> is greater than the length of the\nslice. Note that <code>k == self.len()</code> does <em>not</em> panic and is a no-op\nrotation.</p>\n<h5 id=\"complexity-1\"><a class=\"doc-anchor\" href=\"#complexity-1\">§</a>Complexity</h5>\n<p>Takes linear (in <code>self.len()</code>) time.</p>\n<h5 id=\"examples-85\"><a class=\"doc-anchor\" href=\"#examples-85\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>a = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'f'</span>];\na.rotate_right(<span class=\"number\">2</span>);\n<span class=\"macro\">assert_eq!</span>(a, [<span class=\"string\">'e'</span>, <span class=\"string\">'f'</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>]);</code></pre></div>\n<p>Rotating a subslice:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>a = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'f'</span>];\na[<span class=\"number\">1</span>..<span class=\"number\">5</span>].rotate_right(<span class=\"number\">1</span>);\n<span class=\"macro\">assert_eq!</span>(a, [<span class=\"string\">'a'</span>, <span class=\"string\">'e'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>, <span class=\"string\">'f'</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.fill\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.50.0\">1.50.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#3555-3557\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.fill\" class=\"fn\">fill</a>(&amp;mut self, value: T)<div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>,</div></h4></section></summary><div class=\"docblock\"><p>Fills <code>self</code> with elements by cloning <code>value</code>.</p>\n<h5 id=\"examples-86\"><a class=\"doc-anchor\" href=\"#examples-86\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buf = <span class=\"macro\">vec!</span>[<span class=\"number\">0</span>; <span class=\"number\">10</span>];\nbuf.fill(<span class=\"number\">1</span>);\n<span class=\"macro\">assert_eq!</span>(buf, <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>; <span class=\"number\">10</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.fill_with\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.51.0\">1.51.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#3579-3581\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.fill_with\" class=\"fn\">fill_with</a>&lt;F&gt;(&amp;mut self, f: F)<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>() -&gt; T,</div></h4></section></summary><div class=\"docblock\"><p>Fills <code>self</code> with elements returned by calling a closure repeatedly.</p>\n<p>This method uses a closure to create new values. If you’d rather\n<a href=\"https://doc.rust-lang.org/1.85.0/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\"><code>Clone</code></a> a given value, use <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.fill\" title=\"method slice::fill\"><code>fill</code></a>. If you want to use the <a href=\"https://doc.rust-lang.org/1.85.0/core/default/trait.Default.html\" title=\"trait core::default::Default\"><code>Default</code></a>\ntrait to generate values, you can pass <a href=\"https://doc.rust-lang.org/1.85.0/core/default/trait.Default.html#tymethod.default\" title=\"associated function core::default::Default::default\"><code>Default::default</code></a> as the\nargument.</p>\n<h5 id=\"examples-87\"><a class=\"doc-anchor\" href=\"#examples-87\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>buf = <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>; <span class=\"number\">10</span>];\nbuf.fill_with(Default::default);\n<span class=\"macro\">assert_eq!</span>(buf, <span class=\"macro\">vec!</span>[<span class=\"number\">0</span>; <span class=\"number\">10</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clone_from_slice\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.7.0\">1.7.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#3642-3644\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.clone_from_slice\" class=\"fn\">clone_from_slice</a>(&amp;mut self, src: &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)<div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>,</div></h4></section></summary><div class=\"docblock\"><p>Copies the elements from <code>src</code> into <code>self</code>.</p>\n<p>The length of <code>src</code> must be the same as <code>self</code>.</p>\n<h5 id=\"panics-27\"><a class=\"doc-anchor\" href=\"#panics-27\">§</a>Panics</h5>\n<p>This function will panic if the two slices have different lengths.</p>\n<h5 id=\"examples-88\"><a class=\"doc-anchor\" href=\"#examples-88\">§</a>Examples</h5>\n<p>Cloning two elements from a slice into another:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>src = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>dst = [<span class=\"number\">0</span>, <span class=\"number\">0</span>];\n\n<span class=\"comment\">// Because the slices have to be the same length,\n// we slice the source slice from four elements\n// to two. It will panic if we don't do this.\n</span>dst.clone_from_slice(<span class=\"kw-2\">&amp;</span>src[<span class=\"number\">2</span>..]);\n\n<span class=\"macro\">assert_eq!</span>(src, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]);\n<span class=\"macro\">assert_eq!</span>(dst, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]);</code></pre></div>\n<p>Rust enforces that there can only be one mutable reference with no\nimmutable references to a particular piece of data in a particular\nscope. Because of this, attempting to use <code>clone_from_slice</code> on a\nsingle slice will result in a compile failure:</p>\n\n<div class=\"example-wrap compile_fail\"><a href=\"#\" class=\"tooltip\" title=\"This example deliberately fails to compile\">ⓘ</a><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>slice = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];\n\nslice[..<span class=\"number\">2</span>].clone_from_slice(<span class=\"kw-2\">&amp;</span>slice[<span class=\"number\">3</span>..]); <span class=\"comment\">// compile fail!</span></code></pre></div>\n<p>To work around this, we can use <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.split_at_mut\" title=\"method slice::split_at_mut\"><code>split_at_mut</code></a> to create two distinct\nsub-slices from a slice:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>slice = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];\n\n{\n    <span class=\"kw\">let </span>(left, right) = slice.split_at_mut(<span class=\"number\">2</span>);\n    left.clone_from_slice(<span class=\"kw-2\">&amp;</span>right[<span class=\"number\">1</span>..]);\n}\n\n<span class=\"macro\">assert_eq!</span>(slice, [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.copy_from_slice\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.9.0, const unstable\">1.9.0 (const: <a href=\"https://github.com/rust-lang/rust/issues/131415\" title=\"Tracking issue for const_copy_from_slice\">unstable</a>)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#3707-3709\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.copy_from_slice\" class=\"fn\">copy_from_slice</a>(&amp;mut self, src: &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)<div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/marker/trait.Copy.html\" title=\"trait core::marker::Copy\">Copy</a>,</div></h4></section></summary><div class=\"docblock\"><p>Copies all elements from <code>src</code> into <code>self</code>, using a memcpy.</p>\n<p>The length of <code>src</code> must be the same as <code>self</code>.</p>\n<p>If <code>T</code> does not implement <code>Copy</code>, use <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.clone_from_slice\" title=\"method slice::clone_from_slice\"><code>clone_from_slice</code></a>.</p>\n<h5 id=\"panics-28\"><a class=\"doc-anchor\" href=\"#panics-28\">§</a>Panics</h5>\n<p>This function will panic if the two slices have different lengths.</p>\n<h5 id=\"examples-89\"><a class=\"doc-anchor\" href=\"#examples-89\">§</a>Examples</h5>\n<p>Copying two elements from a slice into another:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>src = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>dst = [<span class=\"number\">0</span>, <span class=\"number\">0</span>];\n\n<span class=\"comment\">// Because the slices have to be the same length,\n// we slice the source slice from four elements\n// to two. It will panic if we don't do this.\n</span>dst.copy_from_slice(<span class=\"kw-2\">&amp;</span>src[<span class=\"number\">2</span>..]);\n\n<span class=\"macro\">assert_eq!</span>(src, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]);\n<span class=\"macro\">assert_eq!</span>(dst, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]);</code></pre></div>\n<p>Rust enforces that there can only be one mutable reference with no\nimmutable references to a particular piece of data in a particular\nscope. Because of this, attempting to use <code>copy_from_slice</code> on a\nsingle slice will result in a compile failure:</p>\n\n<div class=\"example-wrap compile_fail\"><a href=\"#\" class=\"tooltip\" title=\"This example deliberately fails to compile\">ⓘ</a><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>slice = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];\n\nslice[..<span class=\"number\">2</span>].copy_from_slice(<span class=\"kw-2\">&amp;</span>slice[<span class=\"number\">3</span>..]); <span class=\"comment\">// compile fail!</span></code></pre></div>\n<p>To work around this, we can use <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.split_at_mut\" title=\"method slice::split_at_mut\"><code>split_at_mut</code></a> to create two distinct\nsub-slices from a slice:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>slice = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];\n\n{\n    <span class=\"kw\">let </span>(left, right) = slice.split_at_mut(<span class=\"number\">2</span>);\n    left.copy_from_slice(<span class=\"kw-2\">&amp;</span>right[<span class=\"number\">1</span>..]);\n}\n\n<span class=\"macro\">assert_eq!</span>(slice, [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.copy_within\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.37.0\">1.37.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#3763-3765\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.copy_within\" class=\"fn\">copy_within</a>&lt;R&gt;(&amp;mut self, src: R, dest: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>)<div class=\"where\">where\n    R: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/range/trait.RangeBounds.html\" title=\"trait core::ops::range::RangeBounds\">RangeBounds</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;,\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/marker/trait.Copy.html\" title=\"trait core::marker::Copy\">Copy</a>,</div></h4></section></summary><div class=\"docblock\"><p>Copies elements from one part of the slice to another part of itself,\nusing a memmove.</p>\n<p><code>src</code> is the range within <code>self</code> to copy from. <code>dest</code> is the starting\nindex of the range within <code>self</code> to copy to, which will have the same\nlength as <code>src</code>. The two ranges may overlap. The ends of the two ranges\nmust be less than or equal to <code>self.len()</code>.</p>\n<h5 id=\"panics-29\"><a class=\"doc-anchor\" href=\"#panics-29\">§</a>Panics</h5>\n<p>This function will panic if either range exceeds the end of the slice,\nor if the end of <code>src</code> is before the start.</p>\n<h5 id=\"examples-90\"><a class=\"doc-anchor\" href=\"#examples-90\">§</a>Examples</h5>\n<p>Copying four bytes within a slice:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>bytes = <span class=\"kw-2\">*</span><span class=\"string\">b\"Hello, World!\"</span>;\n\nbytes.copy_within(<span class=\"number\">1</span>..<span class=\"number\">5</span>, <span class=\"number\">8</span>);\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">&amp;</span>bytes, <span class=\"string\">b\"Hello, Wello!\"</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.swap_with_slice\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.27.0\">1.27.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#3830\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.swap_with_slice\" class=\"fn\">swap_with_slice</a>(&amp;mut self, other: &amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)</h4></section></summary><div class=\"docblock\"><p>Swaps all elements in <code>self</code> with those in <code>other</code>.</p>\n<p>The length of <code>other</code> must be the same as <code>self</code>.</p>\n<h5 id=\"panics-30\"><a class=\"doc-anchor\" href=\"#panics-30\">§</a>Panics</h5>\n<p>This function will panic if the two slices have different lengths.</p>\n<h5 id=\"example\"><a class=\"doc-anchor\" href=\"#example\">§</a>Example</h5>\n<p>Swapping two elements across slices:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>slice1 = [<span class=\"number\">0</span>, <span class=\"number\">0</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>slice2 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];\n\nslice1.swap_with_slice(<span class=\"kw-2\">&amp;mut </span>slice2[<span class=\"number\">2</span>..]);\n\n<span class=\"macro\">assert_eq!</span>(slice1, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]);\n<span class=\"macro\">assert_eq!</span>(slice2, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]);</code></pre></div>\n<p>Rust enforces that there can only be one mutable reference to a\nparticular piece of data in a particular scope. Because of this,\nattempting to use <code>swap_with_slice</code> on a single slice will result in\na compile failure:</p>\n\n<div class=\"example-wrap compile_fail\"><a href=\"#\" class=\"tooltip\" title=\"This example deliberately fails to compile\">ⓘ</a><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>slice = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];\nslice[..<span class=\"number\">2</span>].swap_with_slice(<span class=\"kw-2\">&amp;mut </span>slice[<span class=\"number\">3</span>..]); <span class=\"comment\">// compile fail!</span></code></pre></div>\n<p>To work around this, we can use <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.split_at_mut\" title=\"method slice::split_at_mut\"><code>split_at_mut</code></a> to create two distinct\nmutable sub-slices from a slice:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>slice = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];\n\n{\n    <span class=\"kw\">let </span>(left, right) = slice.split_at_mut(<span class=\"number\">2</span>);\n    left.swap_with_slice(<span class=\"kw-2\">&amp;mut </span>right[<span class=\"number\">1</span>..]);\n}\n\n<span class=\"macro\">assert_eq!</span>(slice, [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.align_to\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.30.0\">1.30.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#3907\">Source</a></span><h4 class=\"code-header\">pub unsafe fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.align_to\" class=\"fn\">align_to</a>&lt;U&gt;(&amp;self) -&gt; (&amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>, &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[U]</a>, &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)</h4></section></summary><div class=\"docblock\"><p>Transmutes the slice to a slice of another type, ensuring alignment of the types is\nmaintained.</p>\n<p>This method splits the slice into three distinct slices: prefix, correctly aligned middle\nslice of a new type, and the suffix slice. The middle part will be as big as possible under\nthe given alignment constraint and element size.</p>\n<p>This method has no purpose when either input element <code>T</code> or output element <code>U</code> are\nzero-sized and will return the original slice without splitting anything.</p>\n<h5 id=\"safety-7\"><a class=\"doc-anchor\" href=\"#safety-7\">§</a>Safety</h5>\n<p>This method is essentially a <code>transmute</code> with respect to the elements in the returned\nmiddle slice, so all the usual caveats pertaining to <code>transmute::&lt;T, U&gt;</code> also apply here.</p>\n<h5 id=\"examples-91\"><a class=\"doc-anchor\" href=\"#examples-91\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>bytes: [u8; <span class=\"number\">7</span>] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>];\n    <span class=\"kw\">let </span>(prefix, shorts, suffix) = bytes.align_to::&lt;u16&gt;();\n    <span class=\"comment\">// less_efficient_algorithm_for_bytes(prefix);\n    // more_efficient_algorithm_for_aligned_shorts(shorts);\n    // less_efficient_algorithm_for_bytes(suffix);\n</span>}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.align_to_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.30.0\">1.30.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#3972\">Source</a></span><h4 class=\"code-header\">pub unsafe fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.align_to_mut\" class=\"fn\">align_to_mut</a>&lt;U&gt;(&amp;mut self) -&gt; (&amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>, &amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[U]</a>, &amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)</h4></section></summary><div class=\"docblock\"><p>Transmutes the mutable slice to a mutable slice of another type, ensuring alignment of the\ntypes is maintained.</p>\n<p>This method splits the slice into three distinct slices: prefix, correctly aligned middle\nslice of a new type, and the suffix slice. The middle part will be as big as possible under\nthe given alignment constraint and element size.</p>\n<p>This method has no purpose when either input element <code>T</code> or output element <code>U</code> are\nzero-sized and will return the original slice without splitting anything.</p>\n<h5 id=\"safety-8\"><a class=\"doc-anchor\" href=\"#safety-8\">§</a>Safety</h5>\n<p>This method is essentially a <code>transmute</code> with respect to the elements in the returned\nmiddle slice, so all the usual caveats pertaining to <code>transmute::&lt;T, U&gt;</code> also apply here.</p>\n<h5 id=\"examples-92\"><a class=\"doc-anchor\" href=\"#examples-92\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>bytes: [u8; <span class=\"number\">7</span>] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>];\n    <span class=\"kw\">let </span>(prefix, shorts, suffix) = bytes.align_to_mut::&lt;u16&gt;();\n    <span class=\"comment\">// less_efficient_algorithm_for_bytes(prefix);\n    // more_efficient_algorithm_for_aligned_shorts(shorts);\n    // less_efficient_algorithm_for_bytes(suffix);\n</span>}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_simd\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#4063-4067\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.as_simd\" class=\"fn\">as_simd</a>&lt;const LANES: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;(&amp;self) -&gt; (&amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>, &amp;[<a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/core_simd/vector/struct.Simd.html\" title=\"struct core::core_simd::vector::Simd\">Simd</a>&lt;T, LANES&gt;], &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)<div class=\"where\">where\n    <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/core_simd/vector/struct.Simd.html\" title=\"struct core::core_simd::vector::Simd\">Simd</a>&lt;T, LANES&gt;: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/convert/trait.AsRef.html\" title=\"trait core::convert::AsRef\">AsRef</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.array.html\">[T; LANES]</a>&gt;,\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/core_simd/vector/trait.SimdElement.html\" title=\"trait core::core_simd::vector::SimdElement\">SimdElement</a>,\n    <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/core_simd/lane_count/struct.LaneCount.html\" title=\"struct core::core_simd::lane_count::LaneCount\">LaneCount</a>&lt;LANES&gt;: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/core_simd/lane_count/trait.SupportedLaneCount.html\" title=\"trait core::core_simd::lane_count::SupportedLaneCount\">SupportedLaneCount</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>portable_simd</code>)</span></div></span></summary><div class=\"docblock\"><p>Splits a slice into a prefix, a middle of aligned SIMD types, and a suffix.</p>\n<p>This is a safe wrapper around <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.align_to\" title=\"method slice::align_to\"><code>slice::align_to</code></a>, so inherits the same\nguarantees as that method.</p>\n<h5 id=\"panics-31\"><a class=\"doc-anchor\" href=\"#panics-31\">§</a>Panics</h5>\n<p>This will panic if the size of the SIMD type is different from\n<code>LANES</code> times that of the scalar.</p>\n<p>At the time of writing, the trait restrictions on <code>Simd&lt;T, LANES&gt;</code> keeps\nthat from ever happening, as only power-of-two numbers of lanes are\nsupported.  It’s possible that, in the future, those restrictions might\nbe lifted in a way that would make it possible to see panics from this\nmethod for something like <code>LANES == 3</code>.</p>\n<h5 id=\"examples-93\"><a class=\"doc-anchor\" href=\"#examples-93\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(portable_simd)]\n</span><span class=\"kw\">use </span>core::simd::prelude::<span class=\"kw-2\">*</span>;\n\n<span class=\"kw\">let </span>short = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"kw\">let </span>(prefix, middle, suffix) = short.as_simd::&lt;<span class=\"number\">4</span>&gt;();\n<span class=\"macro\">assert_eq!</span>(middle, []); <span class=\"comment\">// Not enough elements for anything in the middle\n\n// They might be split in any possible way between prefix and suffix\n</span><span class=\"kw\">let </span>it = prefix.iter().chain(suffix).copied();\n<span class=\"macro\">assert_eq!</span>(it.collect::&lt;Vec&lt;<span class=\"kw\">_</span>&gt;&gt;(), <span class=\"macro\">vec!</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);\n\n<span class=\"kw\">fn </span>basic_simd_sum(x: <span class=\"kw-2\">&amp;</span>[f32]) -&gt; f32 {\n    <span class=\"kw\">use </span>std::ops::Add;\n    <span class=\"kw\">let </span>(prefix, middle, suffix) = x.as_simd();\n    <span class=\"kw\">let </span>sums = f32x4::from_array([\n        prefix.iter().copied().sum(),\n        <span class=\"number\">0.0</span>,\n        <span class=\"number\">0.0</span>,\n        suffix.iter().copied().sum(),\n    ]);\n    <span class=\"kw\">let </span>sums = middle.iter().copied().fold(sums, f32x4::add);\n    sums.reduce_sum()\n}\n\n<span class=\"kw\">let </span>numbers: Vec&lt;f32&gt; = (<span class=\"number\">1</span>..<span class=\"number\">101</span>).map(|x| x <span class=\"kw\">as _</span>).collect();\n<span class=\"macro\">assert_eq!</span>(basic_simd_sum(<span class=\"kw-2\">&amp;</span>numbers[<span class=\"number\">1</span>..<span class=\"number\">99</span>]), <span class=\"number\">4949.0</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_simd_mut\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#4099-4103\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.as_simd_mut\" class=\"fn\">as_simd_mut</a>&lt;const LANES: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;(\n    &amp;mut self,\n) -&gt; (&amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>, &amp;mut [<a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/core_simd/vector/struct.Simd.html\" title=\"struct core::core_simd::vector::Simd\">Simd</a>&lt;T, LANES&gt;], &amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>)<div class=\"where\">where\n    <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/core_simd/vector/struct.Simd.html\" title=\"struct core::core_simd::vector::Simd\">Simd</a>&lt;T, LANES&gt;: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/convert/trait.AsMut.html\" title=\"trait core::convert::AsMut\">AsMut</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.array.html\">[T; LANES]</a>&gt;,\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/core_simd/vector/trait.SimdElement.html\" title=\"trait core::core_simd::vector::SimdElement\">SimdElement</a>,\n    <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/core_simd/lane_count/struct.LaneCount.html\" title=\"struct core::core_simd::lane_count::LaneCount\">LaneCount</a>&lt;LANES&gt;: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/core_simd/lane_count/trait.SupportedLaneCount.html\" title=\"trait core::core_simd::lane_count::SupportedLaneCount\">SupportedLaneCount</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>portable_simd</code>)</span></div></span></summary><div class=\"docblock\"><p>Splits a mutable slice into a mutable prefix, a middle of aligned SIMD types,\nand a mutable suffix.</p>\n<p>This is a safe wrapper around <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.align_to_mut\" title=\"method slice::align_to_mut\"><code>slice::align_to_mut</code></a>, so inherits the same\nguarantees as that method.</p>\n<p>This is the mutable version of <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.as_simd\" title=\"method slice::as_simd\"><code>slice::as_simd</code></a>; see that for examples.</p>\n<h5 id=\"panics-32\"><a class=\"doc-anchor\" href=\"#panics-32\">§</a>Panics</h5>\n<p>This will panic if the size of the SIMD type is different from\n<code>LANES</code> times that of the scalar.</p>\n<p>At the time of writing, the trait restrictions on <code>Simd&lt;T, LANES&gt;</code> keeps\nthat from ever happening, as only power-of-two numbers of lanes are\nsupported.  It’s possible that, in the future, those restrictions might\nbe lifted in a way that would make it possible to see panics from this\nmethod for something like <code>LANES == 3</code>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_sorted\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.82.0\">1.82.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#4138-4140\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.is_sorted\" class=\"fn\">is_sorted</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html\" title=\"trait core::cmp::PartialOrd\">PartialOrd</a>,</div></h4></section></summary><div class=\"docblock\"><p>Checks if the elements of this slice are sorted.</p>\n<p>That is, for each element <code>a</code> and its following element <code>b</code>, <code>a &lt;= b</code> must hold. If the\nslice yields exactly zero or one element, <code>true</code> is returned.</p>\n<p>Note that if <code>Self::Item</code> is only <code>PartialOrd</code>, but not <code>Ord</code>, the above definition\nimplies that this function returns <code>false</code> if any two consecutive items are not\ncomparable.</p>\n<h5 id=\"examples-94\"><a class=\"doc-anchor\" href=\"#examples-94\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>empty: [i32; <span class=\"number\">0</span>] = [];\n\n<span class=\"macro\">assert!</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>].is_sorted());\n<span class=\"macro\">assert!</span>(![<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>].is_sorted());\n<span class=\"macro\">assert!</span>([<span class=\"number\">0</span>].is_sorted());\n<span class=\"macro\">assert!</span>(empty.is_sorted());\n<span class=\"macro\">assert!</span>(![<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, f32::NAN].is_sorted());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_sorted_by\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.82.0\">1.82.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#4181-4183\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.is_sorted_by\" class=\"fn\">is_sorted_by</a>&lt;'a, F&gt;(&amp;'a self, compare: F) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a><div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;'a T</a>, <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;'a T</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a>,</div></h4></section></summary><div class=\"docblock\"><p>Checks if the elements of this slice are sorted using the given comparator function.</p>\n<p>Instead of using <code>PartialOrd::partial_cmp</code>, this function uses the given <code>compare</code>\nfunction to determine whether two elements are to be considered in sorted order.</p>\n<h5 id=\"examples-95\"><a class=\"doc-anchor\" href=\"#examples-95\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert!</span>([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>].is_sorted_by(|a, b| a &lt;= b));\n<span class=\"macro\">assert!</span>(![<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>].is_sorted_by(|a, b| a &lt; b));\n\n<span class=\"macro\">assert!</span>([<span class=\"number\">0</span>].is_sorted_by(|a, b| <span class=\"bool-val\">true</span>));\n<span class=\"macro\">assert!</span>([<span class=\"number\">0</span>].is_sorted_by(|a, b| <span class=\"bool-val\">false</span>));\n\n<span class=\"kw\">let </span>empty: [i32; <span class=\"number\">0</span>] = [];\n<span class=\"macro\">assert!</span>(empty.is_sorted_by(|a, b| <span class=\"bool-val\">false</span>));\n<span class=\"macro\">assert!</span>(empty.is_sorted_by(|a, b| <span class=\"bool-val\">true</span>));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_sorted_by_key\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.82.0\">1.82.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#4205-4208\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.is_sorted_by_key\" class=\"fn\">is_sorted_by_key</a>&lt;'a, F, K&gt;(&amp;'a self, f: F) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a><div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;'a T</a>) -&gt; K,\n    K: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html\" title=\"trait core::cmp::PartialOrd\">PartialOrd</a>,</div></h4></section></summary><div class=\"docblock\"><p>Checks if the elements of this slice are sorted using the given key extraction function.</p>\n<p>Instead of comparing the slice’s elements directly, this function compares the keys of the\nelements, as determined by <code>f</code>. Apart from that, it’s equivalent to <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.is_sorted\" title=\"method slice::is_sorted\"><code>is_sorted</code></a>; see its\ndocumentation for more information.</p>\n<h5 id=\"examples-96\"><a class=\"doc-anchor\" href=\"#examples-96\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert!</span>([<span class=\"string\">\"c\"</span>, <span class=\"string\">\"bb\"</span>, <span class=\"string\">\"aaa\"</span>].is_sorted_by_key(|s| s.len()));\n<span class=\"macro\">assert!</span>(![-<span class=\"number\">2i32</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>].is_sorted_by_key(|n| n.abs()));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.partition_point\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.52.0\">1.52.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#4264-4266\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.partition_point\" class=\"fn\">partition_point</a>&lt;P&gt;(&amp;self, pred: P) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a><div class=\"where\">where\n    P: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a>,</div></h4></section></summary><div class=\"docblock\"><p>Returns the index of the partition point according to the given predicate\n(the index of the first element of the second partition).</p>\n<p>The slice is assumed to be partitioned according to the given predicate.\nThis means that all elements for which the predicate returns true are at the start of the slice\nand all elements for which the predicate returns false are at the end.\nFor example, <code>[7, 15, 3, 5, 4, 12, 6]</code> is partitioned under the predicate <code>x % 2 != 0</code>\n(all odd numbers are at the start, all even at the end).</p>\n<p>If this slice is not partitioned, the returned result is unspecified and meaningless,\nas this method performs a kind of binary search.</p>\n<p>See also <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.binary_search\" title=\"method slice::binary_search\"><code>binary_search</code></a>, <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.binary_search_by\" title=\"method slice::binary_search_by\"><code>binary_search_by</code></a>, and <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.binary_search_by_key\" title=\"method slice::binary_search_by_key\"><code>binary_search_by_key</code></a>.</p>\n<h5 id=\"examples-97\"><a class=\"doc-anchor\" href=\"#examples-97\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>v = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>];\n<span class=\"kw\">let </span>i = v.partition_point(|<span class=\"kw-2\">&amp;</span>x| x &lt; <span class=\"number\">5</span>);\n\n<span class=\"macro\">assert_eq!</span>(i, <span class=\"number\">4</span>);\n<span class=\"macro\">assert!</span>(v[..i].iter().all(|<span class=\"kw-2\">&amp;</span>x| x &lt; <span class=\"number\">5</span>));\n<span class=\"macro\">assert!</span>(v[i..].iter().all(|<span class=\"kw-2\">&amp;</span>x| !(x &lt; <span class=\"number\">5</span>)));</code></pre></div>\n<p>If all elements of the slice match the predicate, including if the slice\nis empty, then the length of the slice will be returned:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a = [<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>];\n<span class=\"macro\">assert_eq!</span>(a.partition_point(|x| x &lt; <span class=\"kw-2\">&amp;</span><span class=\"number\">100</span>), a.len());\n<span class=\"kw\">let </span>a: [i32; <span class=\"number\">0</span>] = [];\n<span class=\"macro\">assert_eq!</span>(a.partition_point(|x| x &lt; <span class=\"kw-2\">&amp;</span><span class=\"number\">100</span>), <span class=\"number\">0</span>);</code></pre></div>\n<p>If you want to insert an item to a sorted vector, while maintaining\nsort order:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>s = <span class=\"macro\">vec!</span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">13</span>, <span class=\"number\">21</span>, <span class=\"number\">34</span>, <span class=\"number\">55</span>];\n<span class=\"kw\">let </span>num = <span class=\"number\">42</span>;\n<span class=\"kw\">let </span>idx = s.partition_point(|<span class=\"kw-2\">&amp;</span>x| x &lt;= num);\ns.insert(idx, num);\n<span class=\"macro\">assert_eq!</span>(s, [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">13</span>, <span class=\"number\">21</span>, <span class=\"number\">34</span>, <span class=\"number\">42</span>, <span class=\"number\">55</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.take\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#4322\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.take\" class=\"fn\">take</a>&lt;'a, R&gt;(self: &amp;mut &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>, range: R) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;&amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>&gt;<div class=\"where\">where\n    R: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/range/trait.OneSidedRange.html\" title=\"trait core::ops::range::OneSidedRange\">OneSidedRange</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_take</code>)</span></div></span></summary><div class=\"docblock\"><p>Removes the subslice corresponding to the given range\nand returns a reference to it.</p>\n<p>Returns <code>None</code> and does not modify the slice if the given\nrange is out of bounds.</p>\n<p>Note that this method only accepts one-sided ranges such as\n<code>2..</code> or <code>..6</code>, but not <code>2..6</code>.</p>\n<h5 id=\"examples-98\"><a class=\"doc-anchor\" href=\"#examples-98\">§</a>Examples</h5>\n<p>Taking the first three elements of a slice:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(slice_take)]\n\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>slice: <span class=\"kw-2\">&amp;</span>[<span class=\"kw\">_</span>] = <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>first_three = slice.take(..<span class=\"number\">3</span>).unwrap();\n\n<span class=\"macro\">assert_eq!</span>(slice, <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'d'</span>]);\n<span class=\"macro\">assert_eq!</span>(first_three, <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>]);</code></pre></div>\n<p>Taking the last two elements of a slice:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(slice_take)]\n\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>slice: <span class=\"kw-2\">&amp;</span>[<span class=\"kw\">_</span>] = <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>tail = slice.take(<span class=\"number\">2</span>..).unwrap();\n\n<span class=\"macro\">assert_eq!</span>(slice, <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>]);\n<span class=\"macro\">assert_eq!</span>(tail, <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>]);</code></pre></div>\n<p>Getting <code>None</code> when <code>range</code> is out of bounds:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(slice_take)]\n\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>slice: <span class=\"kw-2\">&amp;</span>[<span class=\"kw\">_</span>] = <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>];\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, slice.take(<span class=\"number\">5</span>..));\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, slice.take(..<span class=\"number\">5</span>));\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, slice.take(..=<span class=\"number\">4</span>));\n<span class=\"kw\">let </span>expected: <span class=\"kw-2\">&amp;</span>[char] = <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>];\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(expected), slice.take(..<span class=\"number\">4</span>));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.take_mut\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#4391-4394\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.take_mut\" class=\"fn\">take_mut</a>&lt;'a, R&gt;(self: &amp;mut &amp;'a mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>, range: R) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;&amp;'a mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>&gt;<div class=\"where\">where\n    R: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/range/trait.OneSidedRange.html\" title=\"trait core::ops::range::OneSidedRange\">OneSidedRange</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_take</code>)</span></div></span></summary><div class=\"docblock\"><p>Removes the subslice corresponding to the given range\nand returns a mutable reference to it.</p>\n<p>Returns <code>None</code> and does not modify the slice if the given\nrange is out of bounds.</p>\n<p>Note that this method only accepts one-sided ranges such as\n<code>2..</code> or <code>..6</code>, but not <code>2..6</code>.</p>\n<h5 id=\"examples-99\"><a class=\"doc-anchor\" href=\"#examples-99\">§</a>Examples</h5>\n<p>Taking the first three elements of a slice:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(slice_take)]\n\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>slice: <span class=\"kw-2\">&amp;mut </span>[<span class=\"kw\">_</span>] = <span class=\"kw-2\">&amp;mut </span>[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>first_three = slice.take_mut(..<span class=\"number\">3</span>).unwrap();\n\n<span class=\"macro\">assert_eq!</span>(slice, <span class=\"kw-2\">&amp;mut </span>[<span class=\"string\">'d'</span>]);\n<span class=\"macro\">assert_eq!</span>(first_three, <span class=\"kw-2\">&amp;mut </span>[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>]);</code></pre></div>\n<p>Taking the last two elements of a slice:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(slice_take)]\n\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>slice: <span class=\"kw-2\">&amp;mut </span>[<span class=\"kw\">_</span>] = <span class=\"kw-2\">&amp;mut </span>[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>];\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>tail = slice.take_mut(<span class=\"number\">2</span>..).unwrap();\n\n<span class=\"macro\">assert_eq!</span>(slice, <span class=\"kw-2\">&amp;mut </span>[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>]);\n<span class=\"macro\">assert_eq!</span>(tail, <span class=\"kw-2\">&amp;mut </span>[<span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>]);</code></pre></div>\n<p>Getting <code>None</code> when <code>range</code> is out of bounds:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(slice_take)]\n\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>slice: <span class=\"kw-2\">&amp;mut </span>[<span class=\"kw\">_</span>] = <span class=\"kw-2\">&amp;mut </span>[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>];\n\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, slice.take_mut(<span class=\"number\">5</span>..));\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, slice.take_mut(..<span class=\"number\">5</span>));\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">None</span>, slice.take_mut(..=<span class=\"number\">4</span>));\n<span class=\"kw\">let </span>expected: <span class=\"kw-2\">&amp;mut </span>[<span class=\"kw\">_</span>] = <span class=\"kw-2\">&amp;mut </span>[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>];\n<span class=\"macro\">assert_eq!</span>(<span class=\"prelude-val\">Some</span>(expected), slice.take_mut(..<span class=\"number\">4</span>));</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.take_first\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#4430\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.take_first\" class=\"fn\">take_first</a>&lt;'a&gt;(self: &amp;mut &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;'a T</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_take</code>)</span></div></span></summary><div class=\"docblock\"><p>Removes the first element of the slice and returns a reference\nto it.</p>\n<p>Returns <code>None</code> if the slice is empty.</p>\n<h5 id=\"examples-100\"><a class=\"doc-anchor\" href=\"#examples-100\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(slice_take)]\n\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>slice: <span class=\"kw-2\">&amp;</span>[<span class=\"kw\">_</span>] = <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>];\n<span class=\"kw\">let </span>first = slice.take_first().unwrap();\n\n<span class=\"macro\">assert_eq!</span>(slice, <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>]);\n<span class=\"macro\">assert_eq!</span>(first, <span class=\"kw-2\">&amp;</span><span class=\"string\">'a'</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.take_first_mut\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#4455\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.take_first_mut\" class=\"fn\">take_first_mut</a>&lt;'a&gt;(self: &amp;mut &amp;'a mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;'a mut T</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_take</code>)</span></div></span></summary><div class=\"docblock\"><p>Removes the first element of the slice and returns a mutable\nreference to it.</p>\n<p>Returns <code>None</code> if the slice is empty.</p>\n<h5 id=\"examples-101\"><a class=\"doc-anchor\" href=\"#examples-101\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(slice_take)]\n\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>slice: <span class=\"kw-2\">&amp;mut </span>[<span class=\"kw\">_</span>] = <span class=\"kw-2\">&amp;mut </span>[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>];\n<span class=\"kw\">let </span>first = slice.take_first_mut().unwrap();\n<span class=\"kw-2\">*</span>first = <span class=\"string\">'d'</span>;\n\n<span class=\"macro\">assert_eq!</span>(slice, <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>]);\n<span class=\"macro\">assert_eq!</span>(first, <span class=\"kw-2\">&amp;</span><span class=\"string\">'d'</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.take_last\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#4479\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.take_last\" class=\"fn\">take_last</a>&lt;'a&gt;(self: &amp;mut &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;'a T</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_take</code>)</span></div></span></summary><div class=\"docblock\"><p>Removes the last element of the slice and returns a reference\nto it.</p>\n<p>Returns <code>None</code> if the slice is empty.</p>\n<h5 id=\"examples-102\"><a class=\"doc-anchor\" href=\"#examples-102\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(slice_take)]\n\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>slice: <span class=\"kw-2\">&amp;</span>[<span class=\"kw\">_</span>] = <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>];\n<span class=\"kw\">let </span>last = slice.take_last().unwrap();\n\n<span class=\"macro\">assert_eq!</span>(slice, <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>]);\n<span class=\"macro\">assert_eq!</span>(last, <span class=\"kw-2\">&amp;</span><span class=\"string\">'c'</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.take_last_mut\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#4504\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.take_last_mut\" class=\"fn\">take_last_mut</a>&lt;'a&gt;(self: &amp;mut &amp;'a mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;'a mut T</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_take</code>)</span></div></span></summary><div class=\"docblock\"><p>Removes the last element of the slice and returns a mutable\nreference to it.</p>\n<p>Returns <code>None</code> if the slice is empty.</p>\n<h5 id=\"examples-103\"><a class=\"doc-anchor\" href=\"#examples-103\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(slice_take)]\n\n</span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>slice: <span class=\"kw-2\">&amp;mut </span>[<span class=\"kw\">_</span>] = <span class=\"kw-2\">&amp;mut </span>[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>];\n<span class=\"kw\">let </span>last = slice.take_last_mut().unwrap();\n<span class=\"kw-2\">*</span>last = <span class=\"string\">'d'</span>;\n\n<span class=\"macro\">assert_eq!</span>(slice, <span class=\"kw-2\">&amp;</span>[<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>]);\n<span class=\"macro\">assert_eq!</span>(last, <span class=\"kw-2\">&amp;</span><span class=\"string\">'d'</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_many_unchecked_mut\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#4560-4565\">Source</a><h4 class=\"code-header\">pub unsafe fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.get_many_unchecked_mut\" class=\"fn\">get_many_unchecked_mut</a>&lt;I, const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;(\n    &amp;mut self,\n    indices: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.array.html\">[I; N]</a>,\n) -&gt; [&amp;mut &lt;I as <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/index/trait.SliceIndex.html\" title=\"trait core::slice::index::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>&gt;&gt;::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/index/trait.SliceIndex.html#associatedtype.Output\" title=\"type core::slice::index::SliceIndex::Output\">Output</a>; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.array.html\">N</a>]<div class=\"where\">where\n    I: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/trait.GetManyMutIndex.html\" title=\"trait core::slice::GetManyMutIndex\">GetManyMutIndex</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/index/trait.SliceIndex.html\" title=\"trait core::slice::index::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>&gt;,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>get_many_mut</code>)</span></div></span></summary><div class=\"docblock\"><p>Returns mutable references to many indices at once, without doing any checks.</p>\n<p>An index can be either a <code>usize</code>, a <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/range/struct.Range.html\" title=\"struct core::ops::range::Range\"><code>Range</code></a> or a <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/range/struct.RangeInclusive.html\" title=\"struct core::ops::range::RangeInclusive\"><code>RangeInclusive</code></a>. Note\nthat this method takes an array, so all indices must be of the same type.\nIf passed an array of <code>usize</code>s this method gives back an array of mutable references\nto single elements, while if passed an array of ranges it gives back an array of\nmutable references to slices.</p>\n<p>For a safe alternative see <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.get_many_mut\" title=\"method slice::get_many_mut\"><code>get_many_mut</code></a>.</p>\n<h5 id=\"safety-9\"><a class=\"doc-anchor\" href=\"#safety-9\">§</a>Safety</h5>\n<p>Calling this method with overlapping or out-of-bounds indices is <em><a href=\"https://doc.rust-lang.org/reference/behavior-considered-undefined.html\">undefined behavior</a></em>\neven if the resulting references are not used.</p>\n<h5 id=\"examples-104\"><a class=\"doc-anchor\" href=\"#examples-104\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(get_many_mut)]\n\n</span><span class=\"kw\">let </span>x = <span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>];\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>[a, b] = x.get_many_unchecked_mut([<span class=\"number\">0</span>, <span class=\"number\">2</span>]);\n    <span class=\"kw-2\">*</span>a <span class=\"kw-2\">*</span>= <span class=\"number\">10</span>;\n    <span class=\"kw-2\">*</span>b <span class=\"kw-2\">*</span>= <span class=\"number\">100</span>;\n}\n<span class=\"macro\">assert_eq!</span>(x, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">10</span>, <span class=\"number\">2</span>, <span class=\"number\">400</span>]);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>[a, b] = x.get_many_unchecked_mut([<span class=\"number\">0</span>..<span class=\"number\">1</span>, <span class=\"number\">1</span>..<span class=\"number\">3</span>]);\n    a[<span class=\"number\">0</span>] = <span class=\"number\">8</span>;\n    b[<span class=\"number\">0</span>] = <span class=\"number\">88</span>;\n    b[<span class=\"number\">1</span>] = <span class=\"number\">888</span>;\n}\n<span class=\"macro\">assert_eq!</span>(x, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">8</span>, <span class=\"number\">88</span>, <span class=\"number\">888</span>]);\n\n<span class=\"kw\">unsafe </span>{\n    <span class=\"kw\">let </span>[a, b] = x.get_many_unchecked_mut([<span class=\"number\">1</span>..=<span class=\"number\">2</span>, <span class=\"number\">0</span>..=<span class=\"number\">0</span>]);\n    a[<span class=\"number\">0</span>] = <span class=\"number\">11</span>;\n    a[<span class=\"number\">1</span>] = <span class=\"number\">111</span>;\n    b[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;\n}\n<span class=\"macro\">assert_eq!</span>(x, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">11</span>, <span class=\"number\">111</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_many_mut\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#4629-4634\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.get_many_mut\" class=\"fn\">get_many_mut</a>&lt;I, const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;(\n    &amp;mut self,\n    indices: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.array.html\">[I; N]</a>,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;[&amp;mut &lt;I as <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/index/trait.SliceIndex.html\" title=\"trait core::slice::index::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>&gt;&gt;::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/index/trait.SliceIndex.html#associatedtype.Output\" title=\"type core::slice::index::SliceIndex::Output\">Output</a>; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.array.html\">N</a>], <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/enum.GetManyMutError.html\" title=\"enum core::slice::GetManyMutError\">GetManyMutError</a>&gt;<div class=\"where\">where\n    I: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/trait.GetManyMutIndex.html\" title=\"trait core::slice::GetManyMutIndex\">GetManyMutIndex</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/index/trait.SliceIndex.html\" title=\"trait core::slice::index::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>&gt;,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>get_many_mut</code>)</span></div></span></summary><div class=\"docblock\"><p>Returns mutable references to many indices at once.</p>\n<p>An index can be either a <code>usize</code>, a <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/range/struct.Range.html\" title=\"struct core::ops::range::Range\"><code>Range</code></a> or a <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/range/struct.RangeInclusive.html\" title=\"struct core::ops::range::RangeInclusive\"><code>RangeInclusive</code></a>. Note\nthat this method takes an array, so all indices must be of the same type.\nIf passed an array of <code>usize</code>s this method gives back an array of mutable references\nto single elements, while if passed an array of ranges it gives back an array of\nmutable references to slices.</p>\n<p>Returns an error if any index is out-of-bounds, or if there are overlapping indices.\nAn empty range is not considered to overlap if it is located at the beginning or at\nthe end of another range, but is considered to overlap if it is located in the middle.</p>\n<p>This method does a O(n^2) check to check that there are no overlapping indices, so be careful\nwhen passing many indices.</p>\n<h5 id=\"examples-105\"><a class=\"doc-anchor\" href=\"#examples-105\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(get_many_mut)]\n\n</span><span class=\"kw\">let </span>v = <span class=\"kw-2\">&amp;mut </span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];\n<span class=\"kw\">if let </span><span class=\"prelude-val\">Ok</span>([a, b]) = v.get_many_mut([<span class=\"number\">0</span>, <span class=\"number\">2</span>]) {\n    <span class=\"kw-2\">*</span>a = <span class=\"number\">413</span>;\n    <span class=\"kw-2\">*</span>b = <span class=\"number\">612</span>;\n}\n<span class=\"macro\">assert_eq!</span>(v, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">413</span>, <span class=\"number\">2</span>, <span class=\"number\">612</span>]);\n\n<span class=\"kw\">if let </span><span class=\"prelude-val\">Ok</span>([a, b]) = v.get_many_mut([<span class=\"number\">0</span>..<span class=\"number\">1</span>, <span class=\"number\">1</span>..<span class=\"number\">3</span>]) {\n    a[<span class=\"number\">0</span>] = <span class=\"number\">8</span>;\n    b[<span class=\"number\">0</span>] = <span class=\"number\">88</span>;\n    b[<span class=\"number\">1</span>] = <span class=\"number\">888</span>;\n}\n<span class=\"macro\">assert_eq!</span>(v, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">8</span>, <span class=\"number\">88</span>, <span class=\"number\">888</span>]);\n\n<span class=\"kw\">if let </span><span class=\"prelude-val\">Ok</span>([a, b]) = v.get_many_mut([<span class=\"number\">1</span>..=<span class=\"number\">2</span>, <span class=\"number\">0</span>..=<span class=\"number\">0</span>]) {\n    a[<span class=\"number\">0</span>] = <span class=\"number\">11</span>;\n    a[<span class=\"number\">1</span>] = <span class=\"number\">111</span>;\n    b[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;\n}\n<span class=\"macro\">assert_eq!</span>(v, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">11</span>, <span class=\"number\">111</span>]);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.element_offset\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#4684\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.element_offset\" class=\"fn\">element_offset</a>(&amp;self, element: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>substr_range</code>)</span></div></span></summary><div class=\"docblock\"><p>Returns the index that an element reference points to.</p>\n<p>Returns <code>None</code> if <code>element</code> does not point to the start of an element within the slice.</p>\n<p>This method is useful for extending slice iterators like <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.split\" title=\"method slice::split\"><code>slice::split</code></a>.</p>\n<p>Note that this uses pointer arithmetic and <strong>does not compare elements</strong>.\nTo find the index of an element via comparison, use\n<a href=\"https://doc.rust-lang.org/1.85.0/core/iter/traits/iterator/trait.Iterator.html#method.position\" title=\"method core::iter::traits::iterator::Iterator::position\"><code>.iter().position()</code></a> instead.</p>\n<h5 id=\"panics-33\"><a class=\"doc-anchor\" href=\"#panics-33\">§</a>Panics</h5>\n<p>Panics if <code>T</code> is zero-sized.</p>\n<h5 id=\"examples-106\"><a class=\"doc-anchor\" href=\"#examples-106\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(substr_range)]\n\n</span><span class=\"kw\">let </span>nums: <span class=\"kw-2\">&amp;</span>[u32] = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">7</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>];\n<span class=\"kw\">let </span>num = <span class=\"kw-2\">&amp;</span>nums[<span class=\"number\">2</span>];\n\n<span class=\"macro\">assert_eq!</span>(num, <span class=\"kw-2\">&amp;</span><span class=\"number\">1</span>);\n<span class=\"macro\">assert_eq!</span>(nums.element_offset(num), <span class=\"prelude-val\">Some</span>(<span class=\"number\">2</span>));</code></pre></div>\n<p>Returning <code>None</code> with an unaligned element:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(substr_range)]\n\n</span><span class=\"kw\">let </span>arr: <span class=\"kw-2\">&amp;</span>[[u32; <span class=\"number\">2</span>]] = <span class=\"kw-2\">&amp;</span>[[<span class=\"number\">0</span>, <span class=\"number\">1</span>], [<span class=\"number\">2</span>, <span class=\"number\">3</span>]];\n<span class=\"kw\">let </span>flat_arr: <span class=\"kw-2\">&amp;</span>[u32] = arr.as_flattened();\n\n<span class=\"kw\">let </span>ok_elm: <span class=\"kw-2\">&amp;</span>[u32; <span class=\"number\">2</span>] = flat_arr[<span class=\"number\">0</span>..<span class=\"number\">2</span>].try_into().unwrap();\n<span class=\"kw\">let </span>weird_elm: <span class=\"kw-2\">&amp;</span>[u32; <span class=\"number\">2</span>] = flat_arr[<span class=\"number\">1</span>..<span class=\"number\">3</span>].try_into().unwrap();\n\n<span class=\"macro\">assert_eq!</span>(ok_elm, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0</span>, <span class=\"number\">1</span>]);\n<span class=\"macro\">assert_eq!</span>(weird_elm, <span class=\"kw-2\">&amp;</span>[<span class=\"number\">1</span>, <span class=\"number\">2</span>]);\n\n<span class=\"macro\">assert_eq!</span>(arr.element_offset(ok_elm), <span class=\"prelude-val\">Some</span>(<span class=\"number\">0</span>)); <span class=\"comment\">// Points to element 0\n</span><span class=\"macro\">assert_eq!</span>(arr.element_offset(weird_elm), <span class=\"prelude-val\">None</span>); <span class=\"comment\">// Points between element 0 and 1</span></code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.subslice_range\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#4738\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.subslice_range\" class=\"fn\">subslice_range</a>(&amp;self, subslice: &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/range/struct.Range.html\" title=\"struct core::ops::range::Range\">Range</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt;&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>substr_range</code>)</span></div></span></summary><div class=\"docblock\"><p>Returns the range of indices that a subslice points to.</p>\n<p>Returns <code>None</code> if <code>subslice</code> does not point within the slice or if it is not aligned with the\nelements in the slice.</p>\n<p>This method <strong>does not compare elements</strong>. Instead, this method finds the location in the slice that\n<code>subslice</code> was obtained from. To find the index of a subslice via comparison, instead use\n<a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.windows\" title=\"method slice::windows\"><code>.windows()</code></a><a href=\"https://doc.rust-lang.org/1.85.0/core/iter/traits/iterator/trait.Iterator.html#method.position\" title=\"method core::iter::traits::iterator::Iterator::position\"><code>.position()</code></a>.</p>\n<p>This method is useful for extending slice iterators like <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.split\" title=\"method slice::split\"><code>slice::split</code></a>.</p>\n<p>Note that this may return a false positive (either <code>Some(0..0)</code> or <code>Some(self.len()..self.len())</code>)\nif <code>subslice</code> has a length of zero and points to the beginning or end of another, separate, slice.</p>\n<h5 id=\"panics-34\"><a class=\"doc-anchor\" href=\"#panics-34\">§</a>Panics</h5>\n<p>Panics if <code>T</code> is zero-sized.</p>\n<h5 id=\"examples-107\"><a class=\"doc-anchor\" href=\"#examples-107\">§</a>Examples</h5>\n<p>Basic usage:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(substr_range)]\n\n</span><span class=\"kw\">let </span>nums = <span class=\"kw-2\">&amp;</span>[<span class=\"number\">0</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">5</span>];\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>iter = nums\n    .split(|t| <span class=\"kw-2\">*</span>t == <span class=\"number\">0</span>)\n    .map(|n| nums.subslice_range(n).unwrap());\n\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">0</span>..<span class=\"number\">0</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">1</span>..<span class=\"number\">3</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">4</span>..<span class=\"number\">4</span>));\n<span class=\"macro\">assert_eq!</span>(iter.next(), <span class=\"prelude-val\">Some</span>(<span class=\"number\">5</span>..<span class=\"number\">6</span>));</code></pre></div>\n</div></details></div></details>",0,"retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-%5Bu8%5D\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/slice.rs.html#669\">Source</a><a href=\"#impl-%5Bu8%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.to_ascii_uppercase\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.23.0\">1.23.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/slice.rs.html#685\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.to_ascii_uppercase\" class=\"fn\">to_ascii_uppercase</a>(&amp;self) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Vec&lt;u8&gt;\">ⓘ</a></h4></section></summary><div class=\"docblock\"><p>Returns a vector containing a copy of this slice where each byte\nis mapped to its ASCII upper case equivalent.</p>\n<p>ASCII letters ‘a’ to ‘z’ are mapped to ‘A’ to ‘Z’,\nbut non-ASCII letters are unchanged.</p>\n<p>To uppercase the value in-place, use <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.make_ascii_uppercase\" title=\"method slice::make_ascii_uppercase\"><code>make_ascii_uppercase</code></a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.to_ascii_lowercase\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.23.0\">1.23.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/slice.rs.html#706\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.to_ascii_lowercase\" class=\"fn\">to_ascii_lowercase</a>(&amp;self) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Vec&lt;u8&gt;\">ⓘ</a></h4></section></summary><div class=\"docblock\"><p>Returns a vector containing a copy of this slice where each byte\nis mapped to its ASCII lower case equivalent.</p>\n<p>ASCII letters ‘A’ to ‘Z’ are mapped to ‘a’ to ‘z’,\nbut non-ASCII letters are unchanged.</p>\n<p>To lowercase the value in-place, use <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.make_ascii_lowercase\" title=\"method slice::make_ascii_lowercase\"><code>make_ascii_lowercase</code></a>.</p>\n</div></details></div></details>",0,"retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-%5Bu8%5D\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/ascii.rs.html#11\">Source</a><a href=\"#impl-%5Bu8%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_ascii\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.23.0, const since 1.74.0\">1.23.0 (const: 1.74.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/ascii.rs.html#17\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.is_ascii\" class=\"fn\">is_ascii</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Checks if all bytes in this slice are within the ASCII range.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_ascii\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/ascii.rs.html#26\">Source</a><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.as_ascii\" class=\"fn\">as_ascii</a>(&amp;self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;&amp;[<a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/ascii/ascii_char/enum.AsciiChar.html\" title=\"enum core::ascii::ascii_char::AsciiChar\">AsciiChar</a>]&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>ascii_char</code>)</span></div></span></summary><div class=\"docblock\"><p>If this slice <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.is_ascii\" title=\"method slice::is_ascii\"><code>is_ascii</code></a>, returns it as a slice of\n<a href=\"https://doc.rust-lang.org/1.85.0/core/ascii/ascii_char/enum.AsciiChar.html\" title=\"enum core::ascii::ascii_char::AsciiChar\">ASCII characters</a>, otherwise returns <code>None</code>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_ascii_unchecked\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/ascii.rs.html#44\">Source</a><h4 class=\"code-header\">pub const unsafe fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.as_ascii_unchecked\" class=\"fn\">as_ascii_unchecked</a>(&amp;self) -&gt; &amp;[<a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/ascii/ascii_char/enum.AsciiChar.html\" title=\"enum core::ascii::ascii_char::AsciiChar\">AsciiChar</a>]</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>ascii_char</code>)</span></div></span></summary><div class=\"docblock\"><p>Converts this slice of bytes into a slice of ASCII characters,\nwithout checking whether they’re valid.</p>\n<h5 id=\"safety\"><a class=\"doc-anchor\" href=\"#safety\">§</a>Safety</h5>\n<p>Every byte in the slice must be in <code>0..=127</code>, or else this is UB.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.eq_ignore_ascii_case\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.23.0, const unstable\">1.23.0 (const: <a href=\"https://github.com/rust-lang/rust/issues/131719\" title=\"Tracking issue for const_eq_ignore_ascii_case\">unstable</a>)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/ascii.rs.html#59\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.eq_ignore_ascii_case\" class=\"fn\">eq_ignore_ascii_case</a>(&amp;self, other: &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Checks that two slices are an ASCII case-insensitive match.</p>\n<p>Same as <code>to_ascii_lowercase(a) == to_ascii_lowercase(b)</code>,\nbut without allocating and copying temporaries.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.make_ascii_uppercase\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.23.0, const since 1.84.0\">1.23.0 (const: 1.84.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/ascii.rs.html#94\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.make_ascii_uppercase\" class=\"fn\">make_ascii_uppercase</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Converts this slice to its ASCII upper case equivalent in-place.</p>\n<p>ASCII letters ‘a’ to ‘z’ are mapped to ‘A’ to ‘Z’,\nbut non-ASCII letters are unchanged.</p>\n<p>To return a new uppercased value without modifying the existing one, use\n<a href=\"#method.to_ascii_uppercase\"><code>to_ascii_uppercase</code></a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.make_ascii_lowercase\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.23.0, const since 1.84.0\">1.23.0 (const: 1.84.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/ascii.rs.html#116\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.make_ascii_lowercase\" class=\"fn\">make_ascii_lowercase</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Converts this slice to its ASCII lower case equivalent in-place.</p>\n<p>ASCII letters ‘A’ to ‘Z’ are mapped to ‘a’ to ‘z’,\nbut non-ASCII letters are unchanged.</p>\n<p>To return a new lowercased value without modifying the existing one, use\n<a href=\"#method.to_ascii_lowercase\"><code>to_ascii_lowercase</code></a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.escape_ascii\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.60.0\">1.60.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/ascii.rs.html#140\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.escape_ascii\" class=\"fn\">escape_ascii</a>(&amp;self) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/ascii/struct.EscapeAscii.html\" title=\"struct core::slice::ascii::EscapeAscii\">EscapeAscii</a>&lt;'_&gt;</h4></section></summary><div class=\"docblock\"><p>Returns an iterator that produces an escaped version of this slice,\ntreating it as an ASCII string.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code>\n<span class=\"kw\">let </span>s = <span class=\"string\">b\"0\\t\\r\\n'\\\"\\\\\\x9d\"</span>;\n<span class=\"kw\">let </span>escaped = s.escape_ascii().to_string();\n<span class=\"macro\">assert_eq!</span>(escaped, <span class=\"string\">\"0\\\\t\\\\r\\\\n\\\\'\\\\\\\"\\\\\\\\\\\\x9d\"</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.trim_ascii_start\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.80.0, const since 1.80.0\">1.80.0 (const: 1.80.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/ascii.rs.html#159\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.trim_ascii_start\" class=\"fn\">trim_ascii_start</a>(&amp;self) -&gt; &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>] <a href=\"#\" class=\"tooltip\" data-notable-ty=\"&amp;[u8]\">ⓘ</a></h4></section></summary><div class=\"docblock\"><p>Returns a byte slice with leading ASCII whitespace bytes removed.</p>\n<p>‘Whitespace’ refers to the definition used by\n<a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html#method.is_ascii_whitespace\" title=\"method u8::is_ascii_whitespace\"><code>u8::is_ascii_whitespace</code></a>.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(<span class=\"string\">b\" \\t hello world\\n\"</span>.trim_ascii_start(), <span class=\"string\">b\"hello world\\n\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">b\"  \"</span>.trim_ascii_start(), <span class=\"string\">b\"\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">b\"\"</span>.trim_ascii_start(), <span class=\"string\">b\"\"</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.trim_ascii_end\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.80.0, const since 1.80.0\">1.80.0 (const: 1.80.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/ascii.rs.html#188\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.trim_ascii_end\" class=\"fn\">trim_ascii_end</a>(&amp;self) -&gt; &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>] <a href=\"#\" class=\"tooltip\" data-notable-ty=\"&amp;[u8]\">ⓘ</a></h4></section></summary><div class=\"docblock\"><p>Returns a byte slice with trailing ASCII whitespace bytes removed.</p>\n<p>‘Whitespace’ refers to the definition used by\n<a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html#method.is_ascii_whitespace\" title=\"method u8::is_ascii_whitespace\"><code>u8::is_ascii_whitespace</code></a>.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(<span class=\"string\">b\"\\r hello world\\n \"</span>.trim_ascii_end(), <span class=\"string\">b\"\\r hello world\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">b\"  \"</span>.trim_ascii_end(), <span class=\"string\">b\"\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">b\"\"</span>.trim_ascii_end(), <span class=\"string\">b\"\"</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.trim_ascii\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.80.0, const since 1.80.0\">1.80.0 (const: 1.80.0)</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/ascii.rs.html#218\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.trim_ascii\" class=\"fn\">trim_ascii</a>(&amp;self) -&gt; &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>] <a href=\"#\" class=\"tooltip\" data-notable-ty=\"&amp;[u8]\">ⓘ</a></h4></section></summary><div class=\"docblock\"><p>Returns a byte slice with leading and trailing ASCII whitespace bytes\nremoved.</p>\n<p>‘Whitespace’ refers to the definition used by\n<a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html#method.is_ascii_whitespace\" title=\"method u8::is_ascii_whitespace\"><code>u8::is_ascii_whitespace</code></a>.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"macro\">assert_eq!</span>(<span class=\"string\">b\"\\r hello world\\n \"</span>.trim_ascii(), <span class=\"string\">b\"hello world\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">b\"  \"</span>.trim_ascii(), <span class=\"string\">b\"\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"string\">b\"\"</span>.trim_ascii(), <span class=\"string\">b\"\"</span>);</code></pre></div>\n</div></details></div></details>",0,"retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-%5Bu8%5D\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/str/lossy.rs.html#7\">Source</a><a href=\"#impl-%5Bu8%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.utf8_chunks\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.79.0\">1.79.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/str/lossy.rs.html#44\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#tymethod.utf8_chunks\" class=\"fn\">utf8_chunks</a>(&amp;self) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/str/lossy/struct.Utf8Chunks.html\" title=\"struct core::str::lossy::Utf8Chunks\">Utf8Chunks</a>&lt;'_&gt;</h4></section></summary><div class=\"docblock\"><p>Creates an iterator over the contiguous valid UTF-8 ranges of this\nslice, and the non-UTF-8 fragments in between.</p>\n<p>See the <a href=\"https://doc.rust-lang.org/1.85.0/core/str/lossy/struct.Utf8Chunk.html\" title=\"struct core::str::lossy::Utf8Chunk\"><code>Utf8Chunk</code></a> type for documentation of the items yielded by this iterator.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h5>\n<p>This function formats arbitrary but mostly-UTF-8 bytes into Rust source\ncode in the form of a C-string literal (<code>c\"...\"</code>).</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::fmt::Write <span class=\"kw\">as _</span>;\n\n<span class=\"kw\">pub fn </span>cstr_literal(bytes: <span class=\"kw-2\">&amp;</span>[u8]) -&gt; String {\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>repr = String::new();\n    repr.push_str(<span class=\"string\">\"c\\\"\"</span>);\n    <span class=\"kw\">for </span>chunk <span class=\"kw\">in </span>bytes.utf8_chunks() {\n        <span class=\"kw\">for </span>ch <span class=\"kw\">in </span>chunk.valid().chars() {\n            <span class=\"comment\">// Escapes \\0, \\t, \\r, \\n, \\\\, \\', \\\", and uses \\u{...} for non-printable characters.\n            </span><span class=\"macro\">write!</span>(repr, <span class=\"string\">\"{}\"</span>, ch.escape_debug()).unwrap();\n        }\n        <span class=\"kw\">for </span>byte <span class=\"kw\">in </span>chunk.invalid() {\n            <span class=\"macro\">write!</span>(repr, <span class=\"string\">\"\\\\x{:02X}\"</span>, byte).unwrap();\n        }\n    }\n    repr.push(<span class=\"string\">'\"'</span>);\n    repr\n}\n\n<span class=\"kw\">fn </span>main() {\n    <span class=\"kw\">let </span>lit = cstr_literal(<span class=\"string\">b\"\\xferris the \\xf0\\x9f\\xa6\\x80\\x07\"</span>);\n    <span class=\"kw\">let </span>expected = <span class=\"macro\">stringify!</span>(<span class=\"string\">c\"\\xFErris the 🦀\\u{7}\"</span>);\n    <span class=\"macro\">assert_eq!</span>(lit, expected);\n}</code></pre></div>\n</div></details></div></details>",0,"retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-AsBytes-for-%5Bu8%5D\" class=\"impl\"><a href=\"#impl-AsBytes-for-%5Bu8%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl AsBytes for [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_bytes\" class=\"method trait-impl\"><a href=\"#method.as_bytes\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a class=\"fn\">as_bytes</a>(&amp;self) -&gt; &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>] <a href=\"#\" class=\"tooltip\" data-notable-ty=\"&amp;[u8]\">ⓘ</a></h4></section></summary><div class='docblock'>Casts the input type to a byte slice</div></details></div></details>","AsBytes","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-AsMut%3C%5BT%5D%3E-for-%5BT%5D\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/convert/mod.rs.html#832\">Source</a></span><a href=\"#impl-AsMut%3C%5BT%5D%3E-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/convert/trait.AsMut.html\" title=\"trait core::convert::AsMut\">AsMut</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_mut\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/convert/mod.rs.html#834\">Source</a><a href=\"#method.as_mut\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/convert/trait.AsMut.html#tymethod.as_mut\" class=\"fn\">as_mut</a>(&amp;mut self) -&gt; &amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a></h4></section></summary><div class='docblock'>Converts this type into a mutable reference of the (usually inferred) input type.</div></details></div></details>","AsMut<[T]>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-AsRef%3C%5BT%5D%3E-for-%5BT%5D\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/convert/mod.rs.html#824\">Source</a></span><a href=\"#impl-AsRef%3C%5BT%5D%3E-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/convert/trait.AsRef.html\" title=\"trait core::convert::AsRef\">AsRef</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_ref\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/convert/mod.rs.html#826\">Source</a><a href=\"#method.as_ref\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/convert/trait.AsRef.html#tymethod.as_ref\" class=\"fn\">as_ref</a>(&amp;self) -&gt; &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a></h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details>","AsRef<[T]>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-AsciiExt-for-%5Bu8%5D\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/std/ascii.rs.html#198\">Source</a></span><a href=\"#impl-AsciiExt-for-%5Bu8%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/std/ascii/trait.AsciiExt.html\" title=\"trait std::ascii::AsciiExt\">AsciiExt</a> for [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]</h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Owned\" class=\"associatedtype trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/std/ascii.rs.html#199\">Source</a><a href=\"#associatedtype.Owned\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"https://doc.rust-lang.org/1.85.0/std/ascii/trait.AsciiExt.html#associatedtype.Owned\" class=\"associatedtype\">Owned</a> = <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">👎</span><span>Deprecated since 1.26.0: use inherent methods instead</span></div></span><div class='docblock'>Container type for copied ASCII characters.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_ascii\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/std/ascii.rs.html#201\">Source</a><a href=\"#method.is_ascii\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/std/ascii/trait.AsciiExt.html#tymethod.is_ascii\" class=\"fn\">is_ascii</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">👎</span><span>Deprecated since 1.26.0: use inherent methods instead</span></div></span><div class='docblock'>Checks if the value is within the ASCII range. <a href=\"https://doc.rust-lang.org/1.85.0/std/ascii/trait.AsciiExt.html#tymethod.is_ascii\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.to_ascii_uppercase\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/std/ascii.rs.html#201\">Source</a><a href=\"#method.to_ascii_uppercase\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/std/ascii/trait.AsciiExt.html#tymethod.to_ascii_uppercase\" class=\"fn\">to_ascii_uppercase</a>(&amp;self) -&gt; &lt;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>] as <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/std/ascii/trait.AsciiExt.html\" title=\"trait std::ascii::AsciiExt\">AsciiExt</a>&gt;::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.85.0/std/ascii/trait.AsciiExt.html#associatedtype.Owned\" title=\"type std::ascii::AsciiExt::Owned\">Owned</a> <a href=\"#\" class=\"tooltip\" data-notable-ty=\"&lt;[u8] as AsciiExt&gt;::Owned\">ⓘ</a></h4></section></summary><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">👎</span><span>Deprecated since 1.26.0: use inherent methods instead</span></div></span><div class='docblock'>Makes a copy of the value in its ASCII upper case equivalent. <a href=\"https://doc.rust-lang.org/1.85.0/std/ascii/trait.AsciiExt.html#tymethod.to_ascii_uppercase\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.to_ascii_lowercase\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/std/ascii.rs.html#201\">Source</a><a href=\"#method.to_ascii_lowercase\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/std/ascii/trait.AsciiExt.html#tymethod.to_ascii_lowercase\" class=\"fn\">to_ascii_lowercase</a>(&amp;self) -&gt; &lt;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>] as <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/std/ascii/trait.AsciiExt.html\" title=\"trait std::ascii::AsciiExt\">AsciiExt</a>&gt;::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.85.0/std/ascii/trait.AsciiExt.html#associatedtype.Owned\" title=\"type std::ascii::AsciiExt::Owned\">Owned</a> <a href=\"#\" class=\"tooltip\" data-notable-ty=\"&lt;[u8] as AsciiExt&gt;::Owned\">ⓘ</a></h4></section></summary><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">👎</span><span>Deprecated since 1.26.0: use inherent methods instead</span></div></span><div class='docblock'>Makes a copy of the value in its ASCII lower case equivalent. <a href=\"https://doc.rust-lang.org/1.85.0/std/ascii/trait.AsciiExt.html#tymethod.to_ascii_lowercase\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.eq_ignore_ascii_case\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/std/ascii.rs.html#201\">Source</a><a href=\"#method.eq_ignore_ascii_case\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/std/ascii/trait.AsciiExt.html#tymethod.eq_ignore_ascii_case\" class=\"fn\">eq_ignore_ascii_case</a>(&amp;self, o: &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">👎</span><span>Deprecated since 1.26.0: use inherent methods instead</span></div></span><div class='docblock'>Checks that two values are an ASCII case-insensitive match. <a href=\"https://doc.rust-lang.org/1.85.0/std/ascii/trait.AsciiExt.html#tymethod.eq_ignore_ascii_case\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.make_ascii_uppercase\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/std/ascii.rs.html#201\">Source</a><a href=\"#method.make_ascii_uppercase\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/std/ascii/trait.AsciiExt.html#tymethod.make_ascii_uppercase\" class=\"fn\">make_ascii_uppercase</a>(&amp;mut self)</h4></section></summary><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">👎</span><span>Deprecated since 1.26.0: use inherent methods instead</span></div></span><div class='docblock'>Converts this type to its ASCII upper case equivalent in-place. <a href=\"https://doc.rust-lang.org/1.85.0/std/ascii/trait.AsciiExt.html#tymethod.make_ascii_uppercase\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.make_ascii_lowercase\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/std/ascii.rs.html#201\">Source</a><a href=\"#method.make_ascii_lowercase\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/std/ascii/trait.AsciiExt.html#tymethod.make_ascii_lowercase\" class=\"fn\">make_ascii_lowercase</a>(&amp;mut self)</h4></section></summary><span class=\"item-info\"><div class=\"stab deprecated\"><span class=\"emoji\">👎</span><span>Deprecated since 1.26.0: use inherent methods instead</span></div></span><div class='docblock'>Converts this type to its ASCII lower case equivalent in-place. <a href=\"https://doc.rust-lang.org/1.85.0/std/ascii/trait.AsciiExt.html#tymethod.make_ascii_lowercase\">Read more</a></div></details></div></details>","AsciiExt","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-CloneToUninit-for-%5BT%5D\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/clone.rs.html#282\">Source</a><a href=\"#impl-CloneToUninit-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/clone/trait.CloneToUninit.html\" title=\"trait core::clone::CloneToUninit\">CloneToUninit</a> for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.clone_to_uninit\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/clone.rs.html#285\">Source</a><a href=\"#method.clone_to_uninit\" class=\"anchor\">§</a><h4 class=\"code-header\">unsafe fn <a href=\"https://doc.rust-lang.org/1.85.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit\" class=\"fn\">clone_to_uninit</a>(&amp;self, dst: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.pointer.html\">*mut </a><a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>)</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dst</code>. <a href=\"https://doc.rust-lang.org/1.85.0/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit\">Read more</a></div></details></div></details>","CloneToUninit","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Concat%3CT%3E-for-%5BV%5D\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/slice.rs.html#771\">Source</a><a href=\"#impl-Concat%3CT%3E-for-%5BV%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, V&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/alloc/slice/trait.Concat.html\" title=\"trait alloc::slice::Concat\">Concat</a>&lt;T&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[V]</a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>,\n    V: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/borrow/trait.Borrow.html\" title=\"trait core::borrow::Borrow\">Borrow</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Output\" class=\"associatedtype trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/slice.rs.html#772\">Source</a><a href=\"#associatedtype.Output\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"https://doc.rust-lang.org/1.85.0/alloc/slice/trait.Concat.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;T&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_concat_trait</code>)</span></div></span><div class='docblock'>The resulting type after concatenation</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.concat\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/slice.rs.html#774\">Source</a><a href=\"#method.concat\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/alloc/slice/trait.Concat.html#tymethod.concat\" class=\"fn\">concat</a>(slice: &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[V]</a>) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;T&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_concat_trait</code>)</span></div></span><div class='docblock'>Implementation of <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.concat\" title=\"method slice::concat\"><code>[T]::concat</code></a></div></details></div></details>","Concat<T>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Concat%3Cstr%3E-for-%5BS%5D\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/str.rs.html#62\">Source</a><a href=\"#impl-Concat%3Cstr%3E-for-%5BS%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;S&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/alloc/slice/trait.Concat.html\" title=\"trait alloc::slice::Concat\">Concat</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.str.html\">str</a>&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[S]</a><div class=\"where\">where\n    S: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/borrow/trait.Borrow.html\" title=\"trait core::borrow::Borrow\">Borrow</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.str.html\">str</a>&gt;,</div></h3><div class=\"docblock\"><p>Note: <code>str</code> in <code>Concat&lt;str&gt;</code> is not meaningful here.\nThis type parameter of the trait only exists to enable another impl.</p>\n</div></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Output\" class=\"associatedtype trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/str.rs.html#63\">Source</a><a href=\"#associatedtype.Output\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"https://doc.rust-lang.org/1.85.0/alloc/slice/trait.Concat.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/string/struct.String.html\" title=\"struct alloc::string::String\">String</a></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_concat_trait</code>)</span></div></span><div class='docblock'>The resulting type after concatenation</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.concat\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/str.rs.html#65\">Source</a><a href=\"#method.concat\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/alloc/slice/trait.Concat.html#tymethod.concat\" class=\"fn\">concat</a>(slice: &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[S]</a>) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/string/struct.String.html\" title=\"struct alloc::string::String\">String</a></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_concat_trait</code>)</span></div></span><div class='docblock'>Implementation of <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.concat\" title=\"method slice::concat\"><code>[T]::concat</code></a></div></details></div></details>","Concat<str>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-ConstantTimeEq-for-%5BT%5D\" class=\"impl\"><a class=\"src rightside\" href=\"https://docs.rs/subtle/2.6.0/src/subtle/lib.rs.html#289\">Source</a><a href=\"#impl-ConstantTimeEq-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://docs.rs/subtle/2.6.0/subtle/trait.ConstantTimeEq.html\" title=\"trait subtle::ConstantTimeEq\">ConstantTimeEq</a> for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://docs.rs/subtle/2.6.0/subtle/trait.ConstantTimeEq.html\" title=\"trait subtle::ConstantTimeEq\">ConstantTimeEq</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.ct_eq\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://docs.rs/subtle/2.6.0/src/subtle/lib.rs.html#313\">Source</a><a href=\"#method.ct_eq\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://docs.rs/subtle/2.6.0/subtle/trait.ConstantTimeEq.html#tymethod.ct_eq\" class=\"fn\">ct_eq</a>(&amp;self, _rhs: &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>) -&gt; <a class=\"struct\" href=\"https://docs.rs/subtle/2.6.0/subtle/struct.Choice.html\" title=\"struct subtle::Choice\">Choice</a></h4></section></summary><div class=\"docblock\"><p>Check whether two slices of <code>ConstantTimeEq</code> types are equal.</p>\n<h5 id=\"note\"><a class=\"doc-anchor\" href=\"#note\">§</a>Note</h5>\n<p>This function short-circuits if the lengths of the input slices\nare different.  Otherwise, it should execute in time independent\nof the slice contents.</p>\n<p>Since arrays coerce to slices, this function works with fixed-size arrays:</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>a: [u8; <span class=\"number\">8</span>] = [<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>];\n<span class=\"kw\">let </span>b: [u8; <span class=\"number\">8</span>] = [<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];\n\n<span class=\"kw\">let </span>a_eq_a = a.ct_eq(<span class=\"kw-2\">&amp;</span>a);\n<span class=\"kw\">let </span>a_eq_b = a.ct_eq(<span class=\"kw-2\">&amp;</span>b);\n\n<span class=\"macro\">assert_eq!</span>(a_eq_a.unwrap_u8(), <span class=\"number\">1</span>);\n<span class=\"macro\">assert_eq!</span>(a_eq_b.unwrap_u8(), <span class=\"number\">0</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ct_ne\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://docs.rs/subtle/2.6.0/src/subtle/lib.rs.html#284\">Source</a><a href=\"#method.ct_ne\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://docs.rs/subtle/2.6.0/subtle/trait.ConstantTimeEq.html#method.ct_ne\" class=\"fn\">ct_ne</a>(&amp;self, other: &amp;Self) -&gt; <a class=\"struct\" href=\"https://docs.rs/subtle/2.6.0/subtle/struct.Choice.html\" title=\"struct subtle::Choice\">Choice</a></h4></section></summary><div class='docblock'>Determine if two items are NOT equal. <a href=\"https://docs.rs/subtle/2.6.0/subtle/trait.ConstantTimeEq.html#method.ct_ne\">Read more</a></div></details></div></details>","ConstantTimeEq","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Debug-for-%5BT%5D\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/fmt/mod.rs.html#2892\">Source</a></span><a href=\"#impl-Debug-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a> for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/fmt/mod.rs.html#2893\">Source</a><a href=\"#method.fmt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/fmt/trait.Debug.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/fmt/struct.Formatter.html\" title=\"struct core::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/fmt/struct.Error.html\" title=\"struct core::fmt::Error\">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href=\"https://doc.rust-lang.org/1.85.0/core/fmt/trait.Debug.html#tymethod.fmt\">Read more</a></div></details></div></details>","Debug","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-ExtendInto-for-%5Bu8%5D\" class=\"impl\"><a href=\"#impl-ExtendInto-for-%5Bu8%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl ExtendInto for [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]</h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Item\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Item\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a></h4></section></summary><div class='docblock'>The current input type is a sequence of that <code>Item</code> type. <a>Read more</a></div></details><details class=\"toggle\" open><summary><section id=\"associatedtype.Extender\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Extender\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a class=\"associatedtype\">Extender</a> = <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>&gt;</h4></section></summary><div class='docblock'>The type that will be produced</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.new_builder\" class=\"method trait-impl\"><a href=\"#method.new_builder\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a class=\"fn\">new_builder</a>(&amp;self) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>&gt; <a href=\"#\" class=\"tooltip\" data-notable-ty=\"Vec&lt;u8&gt;\">ⓘ</a></h4></section></summary><div class='docblock'>Create a new <code>Extend</code> of the correct type</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.extend_into\" class=\"method trait-impl\"><a href=\"#method.extend_into\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a class=\"fn\">extend_into</a>(&amp;self, acc: &amp;mut <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>&gt;)</h4></section></summary><div class='docblock'>Accumulate the input into an accumulator</div></details></div></details>","ExtendInto","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-FmtConst-for-%5Bu8%5D\" class=\"impl\"><a class=\"src rightside\" href=\"https://docs.rs/phf_shared/0.9/src/phf_shared/lib.rs.html#254\">Source</a><a href=\"#impl-FmtConst-for-%5Bu8%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"https://docs.rs/phf_shared/0.9/phf_shared/trait.FmtConst.html\" title=\"trait phf_shared::FmtConst\">FmtConst</a> for [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fmt_const\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://docs.rs/phf_shared/0.9/src/phf_shared/lib.rs.html#256\">Source</a><a href=\"#method.fmt_const\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://docs.rs/phf_shared/0.9/phf_shared/trait.FmtConst.html#tymethod.fmt_const\" class=\"fn\">fmt_const</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/fmt/struct.Formatter.html\" title=\"struct core::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/fmt/struct.Error.html\" title=\"struct core::fmt::Error\">Error</a>&gt;</h4></section></summary><div class='docblock'>Print a <code>const</code> expression representing this value.</div></details></div></details>","FmtConst","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Hash-for-%5BT%5D\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/hash/mod.rs.html#938\">Source</a></span><a href=\"#impl-Hash-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/hash/trait.Hash.html\" title=\"trait core::hash::Hash\">Hash</a> for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/hash/trait.Hash.html\" title=\"trait core::hash::Hash\">Hash</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.hash\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/hash/mod.rs.html#940\">Source</a><a href=\"#method.hash\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/hash/trait.Hash.html#tymethod.hash\" class=\"fn\">hash</a>&lt;H&gt;(&amp;self, state: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;mut H</a>)<div class=\"where\">where\n    H: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/hash/trait.Hasher.html\" title=\"trait core::hash::Hasher\">Hasher</a>,</div></h4></section></summary><div class='docblock'>Feeds this value into the given <a href=\"https://doc.rust-lang.org/1.85.0/core/hash/trait.Hasher.html\" title=\"trait core::hash::Hasher\"><code>Hasher</code></a>. <a href=\"https://doc.rust-lang.org/1.85.0/core/hash/trait.Hash.html#tymethod.hash\">Read more</a></div></details></div></details>","Hash","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-HexDisplay-for-%5Bu8%5D\" class=\"impl\"><a href=\"#impl-HexDisplay-for-%5Bu8%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl HexDisplay for [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.to_hex\" class=\"method trait-impl\"><a href=\"#method.to_hex\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a class=\"fn\">to_hex</a>(&amp;self, chunk_size: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/string/struct.String.html\" title=\"struct alloc::string::String\">String</a></h4></section></summary><div class='docblock'>Converts the value of <code>self</code> to a hex dump, returning the owned\n<code>String</code>.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.to_hex_from\" class=\"method trait-impl\"><a href=\"#method.to_hex_from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a class=\"fn\">to_hex_from</a>(&amp;self, chunk_size: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>, from: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/string/struct.String.html\" title=\"struct alloc::string::String\">String</a></h4></section></summary><div class='docblock'>Converts the value of <code>self</code> to a hex dump beginning at <code>from</code> address, returning the owned\n<code>String</code>.</div></details></div></details>","HexDisplay","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Index%3CI%3E-for-%5BT%5D\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/index.rs.html#8-10\">Source</a></span><a href=\"#impl-Index%3CI%3E-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, I&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html\" title=\"trait core::ops::index::Index\">Index</a>&lt;I&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a><div class=\"where\">where\n    I: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/index/trait.SliceIndex.html\" title=\"trait core::slice::index::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Output\" class=\"associatedtype trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/index.rs.html#12\">Source</a><a href=\"#associatedtype.Output\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = &lt;I as <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/index/trait.SliceIndex.html\" title=\"trait core::slice::index::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>&gt;&gt;::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/index/trait.SliceIndex.html#associatedtype.Output\" title=\"type core::slice::index::SliceIndex::Output\">Output</a></h4></section></summary><div class='docblock'>The returned type after indexing.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.index\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/index.rs.html#15\">Source</a><a href=\"#method.index\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html#tymethod.index\" class=\"fn\">index</a>(&amp;self, index: I) -&gt; &amp;&lt;I as <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/index/trait.SliceIndex.html\" title=\"trait core::slice::index::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>&gt;&gt;::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/index/trait.SliceIndex.html#associatedtype.Output\" title=\"type core::slice::index::SliceIndex::Output\">Output</a></h4></section></summary><div class='docblock'>Performs the indexing (<code>container[index]</code>) operation. <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html#tymethod.index\">Read more</a></div></details></div></details>","Index<I>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Index%3CPatternID%3E-for-%5BT%5D\" class=\"impl\"><a href=\"#impl-Index%3CPatternID%3E-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html\" title=\"trait core::ops::index::Index\">Index</a>&lt;PatternID&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Output\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = T</h4></section></summary><div class='docblock'>The returned type after indexing.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.index\" class=\"method trait-impl\"><a href=\"#method.index\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html#tymethod.index\" class=\"fn\">index</a>(&amp;self, index: PatternID) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a></h4></section></summary><div class='docblock'>Performs the indexing (<code>container[index]</code>) operation. <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html#tymethod.index\">Read more</a></div></details></div></details>","Index<PatternID>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Index%3CPatternID%3E-for-%5BT%5D\" class=\"impl\"><a href=\"#impl-Index%3CPatternID%3E-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html\" title=\"trait core::ops::index::Index\">Index</a>&lt;PatternID&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Output\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = T</h4></section></summary><div class='docblock'>The returned type after indexing.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.index\" class=\"method trait-impl\"><a href=\"#method.index\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html#tymethod.index\" class=\"fn\">index</a>(&amp;self, index: PatternID) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a></h4></section></summary><div class='docblock'>Performs the indexing (<code>container[index]</code>) operation. <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html#tymethod.index\">Read more</a></div></details></div></details>","Index<PatternID>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Index%3CSmallIndex%3E-for-%5BT%5D\" class=\"impl\"><a href=\"#impl-Index%3CSmallIndex%3E-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html\" title=\"trait core::ops::index::Index\">Index</a>&lt;SmallIndex&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Output\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = T</h4></section></summary><div class='docblock'>The returned type after indexing.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.index\" class=\"method trait-impl\"><a href=\"#method.index\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html#tymethod.index\" class=\"fn\">index</a>(&amp;self, index: SmallIndex) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a></h4></section></summary><div class='docblock'>Performs the indexing (<code>container[index]</code>) operation. <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html#tymethod.index\">Read more</a></div></details></div></details>","Index<SmallIndex>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Index%3CSmallIndex%3E-for-%5BT%5D\" class=\"impl\"><a href=\"#impl-Index%3CSmallIndex%3E-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html\" title=\"trait core::ops::index::Index\">Index</a>&lt;SmallIndex&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Output\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = T</h4></section></summary><div class='docblock'>The returned type after indexing.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.index\" class=\"method trait-impl\"><a href=\"#method.index\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html#tymethod.index\" class=\"fn\">index</a>(&amp;self, index: SmallIndex) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a></h4></section></summary><div class='docblock'>Performs the indexing (<code>container[index]</code>) operation. <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html#tymethod.index\">Read more</a></div></details></div></details>","Index<SmallIndex>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Index%3CSpan%3E-for-%5Bu8%5D\" class=\"impl\"><a href=\"#impl-Index%3CSpan%3E-for-%5Bu8%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html\" title=\"trait core::ops::index::Index\">Index</a>&lt;Span&gt; for [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]</h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Output\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]</h4></section></summary><div class='docblock'>The returned type after indexing.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.index\" class=\"method trait-impl\"><a href=\"#method.index\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html#tymethod.index\" class=\"fn\">index</a>(&amp;self, index: Span) -&gt; &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>] <a href=\"#\" class=\"tooltip\" data-notable-ty=\"&amp;[u8]\">ⓘ</a></h4></section></summary><div class='docblock'>Performs the indexing (<code>container[index]</code>) operation. <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html#tymethod.index\">Read more</a></div></details></div></details>","Index<Span>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Index%3CSpan%3E-for-%5Bu8%5D\" class=\"impl\"><a href=\"#impl-Index%3CSpan%3E-for-%5Bu8%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html\" title=\"trait core::ops::index::Index\">Index</a>&lt;Span&gt; for [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]</h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Output\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]</h4></section></summary><div class='docblock'>The returned type after indexing.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.index\" class=\"method trait-impl\"><a href=\"#method.index\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html#tymethod.index\" class=\"fn\">index</a>(&amp;self, index: Span) -&gt; &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>] <a href=\"#\" class=\"tooltip\" data-notable-ty=\"&amp;[u8]\">ⓘ</a></h4></section></summary><div class='docblock'>Performs the indexing (<code>container[index]</code>) operation. <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html#tymethod.index\">Read more</a></div></details></div></details>","Index<Span>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Index%3CStateID%3E-for-%5BT%5D\" class=\"impl\"><a href=\"#impl-Index%3CStateID%3E-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html\" title=\"trait core::ops::index::Index\">Index</a>&lt;StateID&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Output\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = T</h4></section></summary><div class='docblock'>The returned type after indexing.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.index\" class=\"method trait-impl\"><a href=\"#method.index\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html#tymethod.index\" class=\"fn\">index</a>(&amp;self, index: StateID) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a></h4></section></summary><div class='docblock'>Performs the indexing (<code>container[index]</code>) operation. <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html#tymethod.index\">Read more</a></div></details></div></details>","Index<StateID>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Index%3CStateID%3E-for-%5BT%5D\" class=\"impl\"><a href=\"#impl-Index%3CStateID%3E-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html\" title=\"trait core::ops::index::Index\">Index</a>&lt;StateID&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Output\" class=\"associatedtype trait-impl\"><a href=\"#associatedtype.Output\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = T</h4></section></summary><div class='docblock'>The returned type after indexing.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.index\" class=\"method trait-impl\"><a href=\"#method.index\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html#tymethod.index\" class=\"fn\">index</a>(&amp;self, index: StateID) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a></h4></section></summary><div class='docblock'>Performs the indexing (<code>container[index]</code>) operation. <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.Index.html#tymethod.index\">Read more</a></div></details></div></details>","Index<StateID>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-IndexMut%3CI%3E-for-%5BT%5D\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/index.rs.html#21-23\">Source</a></span><a href=\"#impl-IndexMut%3CI%3E-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, I&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.IndexMut.html\" title=\"trait core::ops::index::IndexMut\">IndexMut</a>&lt;I&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a><div class=\"where\">where\n    I: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/index/trait.SliceIndex.html\" title=\"trait core::slice::index::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.index_mut\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/index.rs.html#26\">Source</a><a href=\"#method.index_mut\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut\" class=\"fn\">index_mut</a>(&amp;mut self, index: I) -&gt; &amp;mut &lt;I as <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/index/trait.SliceIndex.html\" title=\"trait core::slice::index::SliceIndex\">SliceIndex</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>&gt;&gt;::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/index/trait.SliceIndex.html#associatedtype.Output\" title=\"type core::slice::index::SliceIndex::Output\">Output</a></h4></section></summary><div class='docblock'>Performs the mutable indexing (<code>container[index]</code>) operation. <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut\">Read more</a></div></details></div></details>","IndexMut<I>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-IndexMut%3CPatternID%3E-for-%5BT%5D\" class=\"impl\"><a href=\"#impl-IndexMut%3CPatternID%3E-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.IndexMut.html\" title=\"trait core::ops::index::IndexMut\">IndexMut</a>&lt;PatternID&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.index_mut\" class=\"method trait-impl\"><a href=\"#method.index_mut\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut\" class=\"fn\">index_mut</a>(&amp;mut self, index: PatternID) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;mut T</a></h4></section></summary><div class='docblock'>Performs the mutable indexing (<code>container[index]</code>) operation. <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut\">Read more</a></div></details></div></details>","IndexMut<PatternID>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-IndexMut%3CPatternID%3E-for-%5BT%5D\" class=\"impl\"><a href=\"#impl-IndexMut%3CPatternID%3E-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.IndexMut.html\" title=\"trait core::ops::index::IndexMut\">IndexMut</a>&lt;PatternID&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.index_mut\" class=\"method trait-impl\"><a href=\"#method.index_mut\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut\" class=\"fn\">index_mut</a>(&amp;mut self, index: PatternID) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;mut T</a></h4></section></summary><div class='docblock'>Performs the mutable indexing (<code>container[index]</code>) operation. <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut\">Read more</a></div></details></div></details>","IndexMut<PatternID>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-IndexMut%3CSmallIndex%3E-for-%5BT%5D\" class=\"impl\"><a href=\"#impl-IndexMut%3CSmallIndex%3E-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.IndexMut.html\" title=\"trait core::ops::index::IndexMut\">IndexMut</a>&lt;SmallIndex&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.index_mut\" class=\"method trait-impl\"><a href=\"#method.index_mut\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut\" class=\"fn\">index_mut</a>(&amp;mut self, index: SmallIndex) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;mut T</a></h4></section></summary><div class='docblock'>Performs the mutable indexing (<code>container[index]</code>) operation. <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut\">Read more</a></div></details></div></details>","IndexMut<SmallIndex>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-IndexMut%3CSmallIndex%3E-for-%5BT%5D\" class=\"impl\"><a href=\"#impl-IndexMut%3CSmallIndex%3E-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.IndexMut.html\" title=\"trait core::ops::index::IndexMut\">IndexMut</a>&lt;SmallIndex&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.index_mut\" class=\"method trait-impl\"><a href=\"#method.index_mut\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut\" class=\"fn\">index_mut</a>(&amp;mut self, index: SmallIndex) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;mut T</a></h4></section></summary><div class='docblock'>Performs the mutable indexing (<code>container[index]</code>) operation. <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut\">Read more</a></div></details></div></details>","IndexMut<SmallIndex>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-IndexMut%3CSpan%3E-for-%5Bu8%5D\" class=\"impl\"><a href=\"#impl-IndexMut%3CSpan%3E-for-%5Bu8%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.IndexMut.html\" title=\"trait core::ops::index::IndexMut\">IndexMut</a>&lt;Span&gt; for [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.index_mut\" class=\"method trait-impl\"><a href=\"#method.index_mut\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut\" class=\"fn\">index_mut</a>(&amp;mut self, index: Span) -&gt; &amp;mut [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>] <a href=\"#\" class=\"tooltip\" data-notable-ty=\"&amp;mut [u8]\">ⓘ</a></h4></section></summary><div class='docblock'>Performs the mutable indexing (<code>container[index]</code>) operation. <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut\">Read more</a></div></details></div></details>","IndexMut<Span>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-IndexMut%3CSpan%3E-for-%5Bu8%5D\" class=\"impl\"><a href=\"#impl-IndexMut%3CSpan%3E-for-%5Bu8%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.IndexMut.html\" title=\"trait core::ops::index::IndexMut\">IndexMut</a>&lt;Span&gt; for [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.index_mut\" class=\"method trait-impl\"><a href=\"#method.index_mut\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut\" class=\"fn\">index_mut</a>(&amp;mut self, index: Span) -&gt; &amp;mut [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>] <a href=\"#\" class=\"tooltip\" data-notable-ty=\"&amp;mut [u8]\">ⓘ</a></h4></section></summary><div class='docblock'>Performs the mutable indexing (<code>container[index]</code>) operation. <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut\">Read more</a></div></details></div></details>","IndexMut<Span>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-IndexMut%3CStateID%3E-for-%5BT%5D\" class=\"impl\"><a href=\"#impl-IndexMut%3CStateID%3E-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.IndexMut.html\" title=\"trait core::ops::index::IndexMut\">IndexMut</a>&lt;StateID&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.index_mut\" class=\"method trait-impl\"><a href=\"#method.index_mut\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut\" class=\"fn\">index_mut</a>(&amp;mut self, index: StateID) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;mut T</a></h4></section></summary><div class='docblock'>Performs the mutable indexing (<code>container[index]</code>) operation. <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut\">Read more</a></div></details></div></details>","IndexMut<StateID>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-IndexMut%3CStateID%3E-for-%5BT%5D\" class=\"impl\"><a href=\"#impl-IndexMut%3CStateID%3E-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.IndexMut.html\" title=\"trait core::ops::index::IndexMut\">IndexMut</a>&lt;StateID&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.index_mut\" class=\"method trait-impl\"><a href=\"#method.index_mut\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut\" class=\"fn\">index_mut</a>(&amp;mut self, index: StateID) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;mut T</a></h4></section></summary><div class='docblock'>Performs the mutable indexing (<code>container[index]</code>) operation. <a href=\"https://doc.rust-lang.org/1.85.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut\">Read more</a></div></details></div></details>","IndexMut<StateID>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Join%3C%26%5BT%5D%3E-for-%5BV%5D\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/slice.rs.html#809\">Source</a><a href=\"#impl-Join%3C%26%5BT%5D%3E-for-%5BV%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, V&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/alloc/slice/trait.Join.html\" title=\"trait alloc::slice::Join\">Join</a>&lt;&amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[V]</a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>,\n    V: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/borrow/trait.Borrow.html\" title=\"trait core::borrow::Borrow\">Borrow</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Output\" class=\"associatedtype trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/slice.rs.html#810\">Source</a><a href=\"#associatedtype.Output\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"https://doc.rust-lang.org/1.85.0/alloc/slice/trait.Join.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;T&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_concat_trait</code>)</span></div></span><div class='docblock'>The resulting type after concatenation</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.join\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/slice.rs.html#812\">Source</a><a href=\"#method.join\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/alloc/slice/trait.Join.html#tymethod.join\" class=\"fn\">join</a>(slice: &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[V]</a>, sep: &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;T&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_concat_trait</code>)</span></div></span><div class='docblock'>Implementation of <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.join\" title=\"method slice::join\"><code>[T]::join</code></a></div></details></div></details>","Join<&[T]>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Join%3C%26OsStr%3E-for-%5BS%5D\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/std/ffi/os_str.rs.html#1591\">Source</a><a href=\"#impl-Join%3C%26OsStr%3E-for-%5BS%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;S&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/alloc/slice/trait.Join.html\" title=\"trait alloc::slice::Join\">Join</a>&lt;&amp;<a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/std/ffi/os_str/struct.OsStr.html\" title=\"struct std::ffi::os_str::OsStr\">OsStr</a>&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[S]</a><div class=\"where\">where\n    S: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/borrow/trait.Borrow.html\" title=\"trait core::borrow::Borrow\">Borrow</a>&lt;<a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/std/ffi/os_str/struct.OsStr.html\" title=\"struct std::ffi::os_str::OsStr\">OsStr</a>&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Output\" class=\"associatedtype trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/std/ffi/os_str.rs.html#1592\">Source</a><a href=\"#associatedtype.Output\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"https://doc.rust-lang.org/1.85.0/alloc/slice/trait.Join.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/std/ffi/os_str/struct.OsString.html\" title=\"struct std::ffi::os_str::OsString\">OsString</a></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_concat_trait</code>)</span></div></span><div class='docblock'>The resulting type after concatenation</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.join\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/std/ffi/os_str.rs.html#1594\">Source</a><a href=\"#method.join\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/alloc/slice/trait.Join.html#tymethod.join\" class=\"fn\">join</a>(slice: &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[S]</a>, sep: &amp;<a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/std/ffi/os_str/struct.OsStr.html\" title=\"struct std::ffi::os_str::OsStr\">OsStr</a>) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/std/ffi/os_str/struct.OsString.html\" title=\"struct std::ffi::os_str::OsString\">OsString</a></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_concat_trait</code>)</span></div></span><div class='docblock'>Implementation of <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.join\" title=\"method slice::join\"><code>[T]::join</code></a></div></details></div></details>","Join<&OsStr>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Join%3C%26T%3E-for-%5BV%5D\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/slice.rs.html#786\">Source</a><a href=\"#impl-Join%3C%26T%3E-for-%5BV%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, V&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/alloc/slice/trait.Join.html\" title=\"trait alloc::slice::Join\">Join</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[V]</a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>,\n    V: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/borrow/trait.Borrow.html\" title=\"trait core::borrow::Borrow\">Borrow</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Output\" class=\"associatedtype trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/slice.rs.html#787\">Source</a><a href=\"#associatedtype.Output\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"https://doc.rust-lang.org/1.85.0/alloc/slice/trait.Join.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;T&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_concat_trait</code>)</span></div></span><div class='docblock'>The resulting type after concatenation</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.join\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/slice.rs.html#789\">Source</a><a href=\"#method.join\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/alloc/slice/trait.Join.html#tymethod.join\" class=\"fn\">join</a>(slice: &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[V]</a>, sep: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;T&gt;</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_concat_trait</code>)</span></div></span><div class='docblock'>Implementation of <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.join\" title=\"method slice::join\"><code>[T]::join</code></a></div></details></div></details>","Join<&T>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Join%3C%26str%3E-for-%5BS%5D\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/str.rs.html#72\">Source</a><a href=\"#impl-Join%3C%26str%3E-for-%5BS%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;S&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/alloc/slice/trait.Join.html\" title=\"trait alloc::slice::Join\">Join</a>&lt;&amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.str.html\">str</a>&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[S]</a><div class=\"where\">where\n    S: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/borrow/trait.Borrow.html\" title=\"trait core::borrow::Borrow\">Borrow</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.str.html\">str</a>&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Output\" class=\"associatedtype trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/str.rs.html#73\">Source</a><a href=\"#associatedtype.Output\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"https://doc.rust-lang.org/1.85.0/alloc/slice/trait.Join.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/string/struct.String.html\" title=\"struct alloc::string::String\">String</a></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_concat_trait</code>)</span></div></span><div class='docblock'>The resulting type after concatenation</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.join\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/str.rs.html#75\">Source</a><a href=\"#method.join\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/alloc/slice/trait.Join.html#tymethod.join\" class=\"fn\">join</a>(slice: &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[S]</a>, sep: &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.str.html\">str</a>) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/string/struct.String.html\" title=\"struct alloc::string::String\">String</a></h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_concat_trait</code>)</span></div></span><div class='docblock'>Implementation of <a href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html#method.join\" title=\"method slice::join\"><code>[T]::join</code></a></div></details></div></details>","Join<&str>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-NixPath-for-%5Bu8%5D\" class=\"impl\"><a href=\"#impl-NixPath-for-%5Bu8%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl NixPath for [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_empty\" class=\"method trait-impl\"><a href=\"#method.is_empty\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a class=\"fn\">is_empty</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Is the path empty?</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.len\" class=\"method trait-impl\"><a href=\"#method.len\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a class=\"fn\">len</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a></h4></section></summary><div class='docblock'>Length of the path in bytes</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.with_nix_path\" class=\"method trait-impl\"><a href=\"#method.with_nix_path\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a class=\"fn\">with_nix_path</a>&lt;T, F&gt;(&amp;self, f: F) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;T, Errno&gt;<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/ops/function/trait.FnOnce.html\" title=\"trait core::ops::function::FnOnce\">FnOnce</a>(&amp;<a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/core/ffi/c_str/struct.CStr.html\" title=\"struct core::ffi::c_str::CStr\">CStr</a>) -&gt; T,</div></h4></section></summary><div class='docblock'>Execute a function with this path as a <code>CStr</code>. <a>Read more</a></div></details></div></details>","NixPath","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Offset-for-%5Bu8%5D\" class=\"impl\"><a href=\"#impl-Offset-for-%5Bu8%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl Offset for [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.offset\" class=\"method trait-impl\"><a href=\"#method.offset\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a class=\"fn\">offset</a>(&amp;self, second: &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a></h4></section></summary><div class='docblock'>Offset between the first byte of self and the first byte of the argument</div></details></div></details>","Offset","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Ord-for-%5BT%5D\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/cmp.rs.html#28\">Source</a></span><a href=\"#impl-Ord-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\">Ord</a> for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html\" title=\"trait core::cmp::Ord\">Ord</a>,</div></h3><div class=\"docblock\"><p>Implements comparison of slices <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html#lexicographical-comparison\" title=\"trait core::cmp::Ord\">lexicographically</a>.</p>\n</div></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.cmp\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/cmp.rs.html#29\">Source</a><a href=\"#method.cmp\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html#tymethod.cmp\" class=\"fn\">cmp</a>(&amp;self, other: &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/enum.Ordering.html\" title=\"enum core::cmp::Ordering\">Ordering</a></h4></section></summary><div class='docblock'>This method returns an <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/enum.Ordering.html\" title=\"enum core::cmp::Ordering\"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html#tymethod.cmp\">Read more</a></div></details></div></details>","Ord","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-PartialEq%3C%5BU%5D%3E-for-%5BT%5D\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/cmp.rs.html#10-12\">Source</a></span><a href=\"#impl-PartialEq%3C%5BU%5D%3E-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html\" title=\"trait core::cmp::PartialEq\">PartialEq</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[U]</a>&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html\" title=\"trait core::cmp::PartialEq\">PartialEq</a>&lt;U&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.eq\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/cmp.rs.html#14\">Source</a><a href=\"#method.eq\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html#tymethod.eq\" class=\"fn\">eq</a>(&amp;self, other: &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[U]</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ne\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/cmp.rs.html#18\">Source</a><a href=\"#method.ne\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html#method.ne\" class=\"fn\">ne</a>(&amp;self, other: &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[U]</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,\nand should not be overridden without very good reason.</div></details></div></details>","PartialEq<[U]>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-PartialEq%3C%5BU;+N%5D%3E-for-%5BT%5D\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/array/equality.rs.html#42-44\">Source</a></span><a href=\"#impl-PartialEq%3C%5BU;+N%5D%3E-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U, const N: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.usize.html\">usize</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html\" title=\"trait core::cmp::PartialEq\">PartialEq</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.array.html\">[U; N]</a>&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html\" title=\"trait core::cmp::PartialEq\">PartialEq</a>&lt;U&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.eq\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/array/equality.rs.html#47\">Source</a><a href=\"#method.eq\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html#tymethod.eq\" class=\"fn\">eq</a>(&amp;self, other: &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.array.html\">[U; N]</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ne\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/array/equality.rs.html#55\">Source</a><a href=\"#method.ne\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html#method.ne\" class=\"fn\">ne</a>(&amp;self, other: &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.array.html\">[U; N]</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,\nand should not be overridden without very good reason.</div></details></div></details>","PartialEq<[U; N]>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-PartialEq%3CBytes%3E-for-%5Bu8%5D\" class=\"impl\"><a href=\"#impl-PartialEq%3CBytes%3E-for-%5Bu8%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html\" title=\"trait core::cmp::PartialEq\">PartialEq</a>&lt;Bytes&gt; for [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.eq\" class=\"method trait-impl\"><a href=\"#method.eq\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html#tymethod.eq\" class=\"fn\">eq</a>(&amp;self, other: &amp;Bytes) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ne\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/cmp.rs.html#261\">Source</a></span><a href=\"#method.ne\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html#method.ne\" class=\"fn\">ne</a>(&amp;self, other: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,\nand should not be overridden without very good reason.</div></details></div></details>","PartialEq<Bytes>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-PartialEq%3CBytesMut%3E-for-%5Bu8%5D\" class=\"impl\"><a href=\"#impl-PartialEq%3CBytesMut%3E-for-%5Bu8%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html\" title=\"trait core::cmp::PartialEq\">PartialEq</a>&lt;BytesMut&gt; for [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.eq\" class=\"method trait-impl\"><a href=\"#method.eq\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html#tymethod.eq\" class=\"fn\">eq</a>(&amp;self, other: &amp;BytesMut) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ne\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/cmp.rs.html#261\">Source</a></span><a href=\"#method.ne\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html#method.ne\" class=\"fn\">ne</a>(&amp;self, other: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,\nand should not be overridden without very good reason.</div></details></div></details>","PartialEq<BytesMut>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-PartialEq%3CHeaderValue%3E-for-%5Bu8%5D\" class=\"impl\"><a href=\"#impl-PartialEq%3CHeaderValue%3E-for-%5Bu8%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html\" title=\"trait core::cmp::PartialEq\">PartialEq</a>&lt;HeaderValue&gt; for [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.eq\" class=\"method trait-impl\"><a href=\"#method.eq\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html#tymethod.eq\" class=\"fn\">eq</a>(&amp;self, other: &amp;HeaderValue) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ne\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/cmp.rs.html#261\">Source</a></span><a href=\"#method.ne\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html#method.ne\" class=\"fn\">ne</a>(&amp;self, other: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,\nand should not be overridden without very good reason.</div></details></div></details>","PartialEq<HeaderValue>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-PartialEq%3CSlice%3CU%3E%3E-for-%5BT%5D\" class=\"impl\"><a href=\"#impl-PartialEq%3CSlice%3CU%3E%3E-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html\" title=\"trait core::cmp::PartialEq\">PartialEq</a>&lt;Slice&lt;U&gt;&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html\" title=\"trait core::cmp::PartialEq\">PartialEq</a>&lt;U&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.eq\" class=\"method trait-impl\"><a href=\"#method.eq\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html#tymethod.eq\" class=\"fn\">eq</a>(&amp;self, other: &amp;Slice&lt;U&gt;) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ne\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/cmp.rs.html#261\">Source</a></span><a href=\"#method.ne\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html#method.ne\" class=\"fn\">ne</a>(&amp;self, other: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,\nand should not be overridden without very good reason.</div></details></div></details>","PartialEq<Slice<U>>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-PartialEq%3CVec%3CU,+A%3E%3E-for-%5BT%5D\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.48.0\">1.48.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/vec/partial_eq.rs.html#28\">Source</a></span><a href=\"#impl-PartialEq%3CVec%3CU,+A%3E%3E-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T, U, A&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html\" title=\"trait core::cmp::PartialEq\">PartialEq</a>&lt;<a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;U, A&gt;&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a><div class=\"where\">where\n    A: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/alloc/trait.Allocator.html\" title=\"trait core::alloc::Allocator\">Allocator</a>,\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html\" title=\"trait core::cmp::PartialEq\">PartialEq</a>&lt;U&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.eq\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/vec/partial_eq.rs.html#28\">Source</a><a href=\"#method.eq\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html#tymethod.eq\" class=\"fn\">eq</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;U, A&gt;) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ne\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/vec/partial_eq.rs.html#28\">Source</a><a href=\"#method.ne\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialEq.html#method.ne\" class=\"fn\">ne</a>(&amp;self, other: &amp;<a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;U, A&gt;) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,\nand should not be overridden without very good reason.</div></details></div></details>","PartialEq<Vec<U, A>>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-PartialOrd%3CBytes%3E-for-%5Bu8%5D\" class=\"impl\"><a href=\"#impl-PartialOrd%3CBytes%3E-for-%5Bu8%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html\" title=\"trait core::cmp::PartialOrd\">PartialOrd</a>&lt;Bytes&gt; for [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.partial_cmp\" class=\"method trait-impl\"><a href=\"#method.partial_cmp\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp\" class=\"fn\">partial_cmp</a>(&amp;self, other: &amp;Bytes) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/enum.Ordering.html\" title=\"enum core::cmp::Ordering\">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.lt\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/cmp.rs.html#1335\">Source</a></span><a href=\"#method.lt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.lt\" class=\"fn\">lt</a>(&amp;self, other: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.lt\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.le\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/cmp.rs.html#1353\">Source</a></span><a href=\"#method.le\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.le\" class=\"fn\">le</a>(&amp;self, other: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the\n<code>&lt;=</code> operator. <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.le\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.gt\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/cmp.rs.html#1371\">Source</a></span><a href=\"#method.gt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.gt\" class=\"fn\">gt</a>(&amp;self, other: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code>\noperator. <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.gt\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ge\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/cmp.rs.html#1389\">Source</a></span><a href=\"#method.ge\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.ge\" class=\"fn\">ge</a>(&amp;self, other: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by\nthe <code>&gt;=</code> operator. <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.ge\">Read more</a></div></details></div></details>","PartialOrd<Bytes>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-PartialOrd%3CBytesMut%3E-for-%5Bu8%5D\" class=\"impl\"><a href=\"#impl-PartialOrd%3CBytesMut%3E-for-%5Bu8%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html\" title=\"trait core::cmp::PartialOrd\">PartialOrd</a>&lt;BytesMut&gt; for [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.partial_cmp\" class=\"method trait-impl\"><a href=\"#method.partial_cmp\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp\" class=\"fn\">partial_cmp</a>(&amp;self, other: &amp;BytesMut) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/enum.Ordering.html\" title=\"enum core::cmp::Ordering\">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.lt\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/cmp.rs.html#1335\">Source</a></span><a href=\"#method.lt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.lt\" class=\"fn\">lt</a>(&amp;self, other: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.lt\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.le\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/cmp.rs.html#1353\">Source</a></span><a href=\"#method.le\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.le\" class=\"fn\">le</a>(&amp;self, other: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the\n<code>&lt;=</code> operator. <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.le\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.gt\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/cmp.rs.html#1371\">Source</a></span><a href=\"#method.gt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.gt\" class=\"fn\">gt</a>(&amp;self, other: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code>\noperator. <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.gt\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ge\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/cmp.rs.html#1389\">Source</a></span><a href=\"#method.ge\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.ge\" class=\"fn\">ge</a>(&amp;self, other: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by\nthe <code>&gt;=</code> operator. <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.ge\">Read more</a></div></details></div></details>","PartialOrd<BytesMut>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-PartialOrd%3CHeaderValue%3E-for-%5Bu8%5D\" class=\"impl\"><a href=\"#impl-PartialOrd%3CHeaderValue%3E-for-%5Bu8%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html\" title=\"trait core::cmp::PartialOrd\">PartialOrd</a>&lt;HeaderValue&gt; for [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.partial_cmp\" class=\"method trait-impl\"><a href=\"#method.partial_cmp\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp\" class=\"fn\">partial_cmp</a>(&amp;self, other: &amp;HeaderValue) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/enum.Ordering.html\" title=\"enum core::cmp::Ordering\">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.lt\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/cmp.rs.html#1335\">Source</a></span><a href=\"#method.lt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.lt\" class=\"fn\">lt</a>(&amp;self, other: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.lt\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.le\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/cmp.rs.html#1353\">Source</a></span><a href=\"#method.le\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.le\" class=\"fn\">le</a>(&amp;self, other: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the\n<code>&lt;=</code> operator. <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.le\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.gt\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/cmp.rs.html#1371\">Source</a></span><a href=\"#method.gt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.gt\" class=\"fn\">gt</a>(&amp;self, other: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code>\noperator. <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.gt\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ge\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/cmp.rs.html#1389\">Source</a></span><a href=\"#method.ge\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.ge\" class=\"fn\">ge</a>(&amp;self, other: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by\nthe <code>&gt;=</code> operator. <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.ge\">Read more</a></div></details></div></details>","PartialOrd<HeaderValue>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-PartialOrd-for-%5BT%5D\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/cmp.rs.html#36\">Source</a></span><a href=\"#impl-PartialOrd-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html\" title=\"trait core::cmp::PartialOrd\">PartialOrd</a> for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html\" title=\"trait core::cmp::PartialOrd\">PartialOrd</a>,</div></h3><div class=\"docblock\"><p>Implements comparison of slices <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Ord.html#lexicographical-comparison\" title=\"trait core::cmp::Ord\">lexicographically</a>.</p>\n</div></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.partial_cmp\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/cmp.rs.html#37\">Source</a><a href=\"#method.partial_cmp\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp\" class=\"fn\">partial_cmp</a>(&amp;self, other: &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a>) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/option/enum.Option.html\" title=\"enum core::option::Option\">Option</a>&lt;<a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/enum.Ordering.html\" title=\"enum core::cmp::Ordering\">Ordering</a>&gt;</h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.lt\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/cmp.rs.html#1335\">Source</a></span><a href=\"#method.lt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.lt\" class=\"fn\">lt</a>(&amp;self, other: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.lt\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.le\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/cmp.rs.html#1353\">Source</a></span><a href=\"#method.le\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.le\" class=\"fn\">le</a>(&amp;self, other: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the\n<code>&lt;=</code> operator. <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.le\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.gt\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/cmp.rs.html#1371\">Source</a></span><a href=\"#method.gt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.gt\" class=\"fn\">gt</a>(&amp;self, other: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code>\noperator. <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.gt\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.ge\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/cmp.rs.html#1389\">Source</a></span><a href=\"#method.ge\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.ge\" class=\"fn\">ge</a>(&amp;self, other: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;Rhs</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class='docblock'>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by\nthe <code>&gt;=</code> operator. <a href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.PartialOrd.html#method.ge\">Read more</a></div></details></div></details>","PartialOrd","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-PhfBorrow%3C%5Bu8%5D%3E-for-%5Bu8%5D\" class=\"impl\"><a class=\"src rightside\" href=\"https://docs.rs/phf_shared/0.9/src/phf_shared/lib.rs.html#166-181\">Source</a><a href=\"#impl-PhfBorrow%3C%5Bu8%5D%3E-for-%5Bu8%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"https://docs.rs/phf_shared/0.9/phf_shared/trait.PhfBorrow.html\" title=\"trait phf_shared::PhfBorrow\">PhfBorrow</a>&lt;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]&gt; for [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.borrow\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://docs.rs/phf_shared/0.9/src/phf_shared/lib.rs.html#166-181\">Source</a><a href=\"#method.borrow\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://docs.rs/phf_shared/0.9/phf_shared/trait.PhfBorrow.html#tymethod.borrow\" class=\"fn\">borrow</a>(&amp;self) -&gt; &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>] <a href=\"#\" class=\"tooltip\" data-notable-ty=\"&amp;[u8]\">ⓘ</a></h4></section></summary><div class='docblock'>Convert a reference to <code>self</code> to a reference to the borrowed type.</div></details></div></details>","PhfBorrow<[u8]>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-PhfHash-for-%5Bu8%5D\" class=\"impl\"><a class=\"src rightside\" href=\"https://docs.rs/phf_shared/0.9/src/phf_shared/lib.rs.html#247\">Source</a><a href=\"#impl-PhfHash-for-%5Bu8%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl <a class=\"trait\" href=\"https://docs.rs/phf_shared/0.9/phf_shared/trait.PhfHash.html\" title=\"trait phf_shared::PhfHash\">PhfHash</a> for [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.phf_hash\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://docs.rs/phf_shared/0.9/src/phf_shared/lib.rs.html#249\">Source</a><a href=\"#method.phf_hash\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://docs.rs/phf_shared/0.9/phf_shared/trait.PhfHash.html#tymethod.phf_hash\" class=\"fn\">phf_hash</a>&lt;H&gt;(&amp;self, state: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.reference.html\">&amp;mut H</a>)<div class=\"where\">where\n    H: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/hash/trait.Hasher.html\" title=\"trait core::hash::Hasher\">Hasher</a>,</div></h4></section></summary><div class='docblock'>Feeds the value into the state given, updating the hasher as necessary.</div></details></div></details>","PhfHash","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Serialize-for-%5BT%5D\" class=\"impl\"><a class=\"src rightside\" href=\"https://docs.rs/serde_core/1.0.225/src/serde_core/ser/impls.rs.html#175-177\">Source</a><a href=\"#impl-Serialize-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://docs.rs/serde_core/1.0.225/serde_core/ser/trait.Serialize.html\" title=\"trait serde_core::ser::Serialize\">Serialize</a> for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://docs.rs/serde_core/1.0.225/serde_core/ser/trait.Serialize.html\" title=\"trait serde_core::ser::Serialize\">Serialize</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.serialize\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://docs.rs/serde_core/1.0.225/src/serde_core/ser/impls.rs.html#180-182\">Source</a><a href=\"#method.serialize\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://docs.rs/serde_core/1.0.225/serde_core/ser/trait.Serialize.html#tymethod.serialize\" class=\"fn\">serialize</a>&lt;S&gt;(\n    &amp;self,\n    serializer: S,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.85.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;&lt;S as <a class=\"trait\" href=\"https://docs.rs/serde_core/1.0.225/serde_core/ser/trait.Serializer.html\" title=\"trait serde_core::ser::Serializer\">Serializer</a>&gt;::<a class=\"associatedtype\" href=\"https://docs.rs/serde_core/1.0.225/serde_core/ser/trait.Serializer.html#associatedtype.Ok\" title=\"type serde_core::ser::Serializer::Ok\">Ok</a>, &lt;S as <a class=\"trait\" href=\"https://docs.rs/serde_core/1.0.225/serde_core/ser/trait.Serializer.html\" title=\"trait serde_core::ser::Serializer\">Serializer</a>&gt;::<a class=\"associatedtype\" href=\"https://docs.rs/serde_core/1.0.225/serde_core/ser/trait.Serializer.html#associatedtype.Error\" title=\"type serde_core::ser::Serializer::Error\">Error</a>&gt;<div class=\"where\">where\n    S: <a class=\"trait\" href=\"https://docs.rs/serde_core/1.0.225/serde_core/ser/trait.Serializer.html\" title=\"trait serde_core::ser::Serializer\">Serializer</a>,</div></h4></section></summary><div class='docblock'>Serialize this value into the given Serde serializer. <a href=\"https://docs.rs/serde_core/1.0.225/serde_core/ser/trait.Serialize.html#tymethod.serialize\">Read more</a></div></details></div></details>","Serialize","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-SlicePattern-for-%5BT%5D\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.51.0\">1.51.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#4957\">Source</a></span><a href=\"#impl-SlicePattern-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/trait.SlicePattern.html\" title=\"trait core::slice::SlicePattern\">SlicePattern</a> for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Item\" class=\"associatedtype trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#4958\">Source</a><a href=\"#associatedtype.Item\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"https://doc.rust-lang.org/1.85.0/core/slice/trait.SlicePattern.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = T</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_pattern</code>)</span></div></span><div class='docblock'>The element type of the slice being matched on.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.as_slice\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/mod.rs.html#4961\">Source</a><a href=\"#method.as_slice\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/core/slice/trait.SlicePattern.html#tymethod.as_slice\" class=\"fn\">as_slice</a>(&amp;self) -&gt; &amp;[&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a> as <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/trait.SlicePattern.html\" title=\"trait core::slice::SlicePattern\">SlicePattern</a>&gt;::<a class=\"associatedtype\" href=\"https://doc.rust-lang.org/1.85.0/core/slice/trait.SlicePattern.html#associatedtype.Item\" title=\"type core::slice::SlicePattern::Item\">Item</a>]</h4></section></summary><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">🔬</span><span>This is a nightly-only experimental API. (<code>slice_pattern</code>)</span></div></span><div class='docblock'>Currently, the consumers of <code>SlicePattern</code> need a slice.</div></details></div></details>","SlicePattern","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-ToOwned-for-%5BT%5D\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/slice.rs.html#883\">Source</a></span><a href=\"#impl-ToOwned-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/alloc/borrow/trait.ToOwned.html\" title=\"trait alloc::borrow::ToOwned\">ToOwned</a> for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle\" open><summary><section id=\"associatedtype.Owned\" class=\"associatedtype trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/slice.rs.html#884\">Source</a><a href=\"#associatedtype.Owned\" class=\"anchor\">§</a><h4 class=\"code-header\">type <a href=\"https://doc.rust-lang.org/1.85.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned\" class=\"associatedtype\">Owned</a> = <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;T&gt;</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.to_owned\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/slice.rs.html#886\">Source</a><a href=\"#method.to_owned\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned\" class=\"fn\">to_owned</a>(&amp;self) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;T&gt;</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href=\"https://doc.rust-lang.org/1.85.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clone_into\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/alloc/slice.rs.html#895\">Source</a><a href=\"#method.clone_into\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.85.0/alloc/borrow/trait.ToOwned.html#method.clone_into\" class=\"fn\">clone_into</a>(&amp;self, target: &amp;mut <a class=\"struct\" href=\"https://doc.rust-lang.org/1.85.0/alloc/vec/struct.Vec.html\" title=\"struct alloc::vec::Vec\">Vec</a>&lt;T&gt;)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href=\"https://doc.rust-lang.org/1.85.0/alloc/borrow/trait.ToOwned.html#method.clone_into\">Read more</a></div></details></div></details>","ToOwned","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-ToSmallVec%3CA%3E-for-%5B%3CA+as+Array%3E::Item%5D\" class=\"impl\"><a href=\"#impl-ToSmallVec%3CA%3E-for-%5B%3CA+as+Array%3E::Item%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;A&gt; ToSmallVec&lt;A&gt; for [&lt;A as Array&gt;::Item]<div class=\"where\">where\n    A: Array,\n    &lt;A as Array&gt;::Item: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/marker/trait.Copy.html\" title=\"trait core::marker::Copy\">Copy</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.to_smallvec\" class=\"method trait-impl\"><a href=\"#method.to_smallvec\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a class=\"fn\">to_smallvec</a>(&amp;self) -&gt; SmallVec&lt;A&gt;</h4></section></summary><div class='docblock'>Construct a new <code>SmallVec</code> from a slice.</div></details></div></details>","ToSmallVec<A>","retina_datatypes::packet::Payload"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Value-for-%5Bu8%5D\" class=\"impl\"><a href=\"#impl-Value-for-%5Bu8%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl Value for [<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.u8.html\">u8</a>]</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.record\" class=\"method trait-impl\"><a href=\"#method.record\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a class=\"fn\">record</a>(&amp;self, key: &amp;Field, visitor: &amp;mut dyn Visit)</h4></section></summary><div class='docblock'>Visits this value with the given <code>Visitor</code>.</div></details></div></details>","Value","retina_datatypes::packet::Payload"],["<section id=\"impl-Eq-for-%5BT%5D\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/cmp.rs.html#24\">Source</a></span><a href=\"#impl-Eq-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Eq.html\" title=\"trait core::cmp::Eq\">Eq</a> for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/cmp/trait.Eq.html\" title=\"trait core::cmp::Eq\">Eq</a>,</div></h3></section>","Eq","retina_datatypes::packet::Payload"],["<section id=\"impl-Iterator-for-%5BT%5D\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.80.0\">1.80.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.85.0/src/core/slice/iter.rs.html#18\">Source</a></span><a href=\"#impl-Iterator-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; !<a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a></h3></section>","Iterator","retina_datatypes::packet::Payload"],["<section id=\"impl-StructuralPartialEq-for-%5BT%5D\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/marker.rs.html#220-232\">Source</a><a href=\"#impl-StructuralPartialEq-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/marker/trait.StructuralPartialEq.html\" title=\"trait core::marker::StructuralPartialEq\">StructuralPartialEq</a> for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a></h3></section>","StructuralPartialEq","retina_datatypes::packet::Payload"],["<section id=\"impl-UnsizedConstParamTy-for-%5BT%5D\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/1.85.0/src/core/marker.rs.html#1067-1080\">Source</a><a href=\"#impl-UnsizedConstParamTy-for-%5BT%5D\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/marker/trait.UnsizedConstParamTy.html\" title=\"trait core::marker::UnsizedConstParamTy\">UnsizedConstParamTy</a> for <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.85.0/std/primitive.slice.html\">[T]</a><div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.85.0/core/marker/trait.UnsizedConstParamTy.html\" title=\"trait core::marker::UnsizedConstParamTy\">UnsizedConstParamTy</a>,</div></h3></section>","UnsizedConstParamTy","retina_datatypes::packet::Payload"]]]]);
    if (window.register_type_impls) {
        window.register_type_impls(type_impls);
    } else {
        window.pending_type_impls = type_impls;
    }
})()
//{"start":55,"fragment_lengths":[541701]}